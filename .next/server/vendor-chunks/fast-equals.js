"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fast-equals";
exports.ids = ["vendor-chunks/fast-equals"];
exports.modules = {

/***/ "(ssr)/./node_modules/fast-equals/dist/esm/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/fast-equals/dist/esm/index.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   circularDeepEqual: () => (/* binding */ circularDeepEqual),\n/* harmony export */   circularShallowEqual: () => (/* binding */ circularShallowEqual),\n/* harmony export */   createCustomEqual: () => (/* binding */ createCustomEqual),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   sameValueZeroEqual: () => (/* binding */ sameValueZeroEqual),\n/* harmony export */   shallowEqual: () => (/* binding */ shallowEqual),\n/* harmony export */   strictCircularDeepEqual: () => (/* binding */ strictCircularDeepEqual),\n/* harmony export */   strictCircularShallowEqual: () => (/* binding */ strictCircularShallowEqual),\n/* harmony export */   strictDeepEqual: () => (/* binding */ strictDeepEqual),\n/* harmony export */   strictShallowEqual: () => (/* binding */ strictShallowEqual)\n/* harmony export */ });\nvar getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * Combine two comparators into a single comparators.\n */ function combineComparators(comparatorA, comparatorB) {\n    return function isEqual(a, b, state) {\n        return comparatorA(a, b, state) && comparatorB(a, b, state);\n    };\n}\n/**\n * Wrap the provided `areItemsEqual` method to manage the circular state, allowing\n * for circular references to be safely included in the comparison without creating\n * stack overflows.\n */ function createIsCircular(areItemsEqual) {\n    return function isCircular(a, b, state) {\n        if (!a || !b || typeof a !== \"object\" || typeof b !== \"object\") {\n            return areItemsEqual(a, b, state);\n        }\n        var cache = state.cache;\n        var cachedA = cache.get(a);\n        var cachedB = cache.get(b);\n        if (cachedA && cachedB) {\n            return cachedA === b && cachedB === a;\n        }\n        cache.set(a, b);\n        cache.set(b, a);\n        var result = areItemsEqual(a, b, state);\n        cache.delete(a);\n        cache.delete(b);\n        return result;\n    };\n}\n/**\n * Get the `@@toStringTag` of the value, if it exists.\n */ function getShortTag(value) {\n    return value != null ? value[Symbol.toStringTag] : undefined;\n}\n/**\n * Get the properties to strictly examine, which include both own properties that are\n * not enumerable and symbol properties.\n */ function getStrictProperties(object) {\n    return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));\n}\n/**\n * Whether the object contains the property passed as an own property.\n */ var hasOwn = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nObject.hasOwn || function(object, property) {\n    return hasOwnProperty.call(object, property);\n};\n/**\n * Whether the values passed are strictly equal or both NaN.\n */ function sameValueZeroEqual(a, b) {\n    return a === b || !a && !b && a !== a && b !== b;\n}\nvar PREACT_VNODE = \"__v\";\nvar PREACT_OWNER = \"__o\";\nvar REACT_OWNER = \"_owner\";\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, keys = Object.keys;\n/**\n * Whether the arrays are equal in value.\n */ function areArraysEqual(a, b, state) {\n    var index = a.length;\n    if (b.length !== index) {\n        return false;\n    }\n    while(index-- > 0){\n        if (!state.equals(a[index], b[index], index, index, a, b, state)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the dates passed are equal in value.\n */ function areDatesEqual(a, b) {\n    return sameValueZeroEqual(a.getTime(), b.getTime());\n}\n/**\n * Whether the errors passed are equal in value.\n */ function areErrorsEqual(a, b) {\n    return a.name === b.name && a.message === b.message && a.cause === b.cause && a.stack === b.stack;\n}\n/**\n * Whether the functions passed are equal in value.\n */ function areFunctionsEqual(a, b) {\n    return a === b;\n}\n/**\n * Whether the `Map`s are equal in value.\n */ function areMapsEqual(a, b, state) {\n    var size = a.size;\n    if (size !== b.size) {\n        return false;\n    }\n    if (!size) {\n        return true;\n    }\n    var matchedIndices = new Array(size);\n    var aIterable = a.entries();\n    var aResult;\n    var bResult;\n    var index = 0;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    while(aResult = aIterable.next()){\n        if (aResult.done) {\n            break;\n        }\n        var bIterable = b.entries();\n        var hasMatch = false;\n        var matchIndex = 0;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        while(bResult = bIterable.next()){\n            if (bResult.done) {\n                break;\n            }\n            if (matchedIndices[matchIndex]) {\n                matchIndex++;\n                continue;\n            }\n            var aEntry = aResult.value;\n            var bEntry = bResult.value;\n            if (state.equals(aEntry[0], bEntry[0], index, matchIndex, a, b, state) && state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a, b, state)) {\n                hasMatch = matchedIndices[matchIndex] = true;\n                break;\n            }\n            matchIndex++;\n        }\n        if (!hasMatch) {\n            return false;\n        }\n        index++;\n    }\n    return true;\n}\n/**\n * Whether the numbers are equal in value.\n */ var areNumbersEqual = sameValueZeroEqual;\n/**\n * Whether the objects are equal in value.\n */ function areObjectsEqual(a, b, state) {\n    var properties = keys(a);\n    var index = properties.length;\n    if (keys(b).length !== index) {\n        return false;\n    }\n    // Decrementing `while` showed faster results than either incrementing or\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\n    // methods like `some` / `every` were not used to avoid incurring the garbage\n    // cost of anonymous callbacks.\n    while(index-- > 0){\n        if (!isPropertyEqual(a, b, state, properties[index])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the objects are equal in value with strict property checking.\n */ function areObjectsEqualStrict(a, b, state) {\n    var properties = getStrictProperties(a);\n    var index = properties.length;\n    if (getStrictProperties(b).length !== index) {\n        return false;\n    }\n    var property;\n    var descriptorA;\n    var descriptorB;\n    // Decrementing `while` showed faster results than either incrementing or\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\n    // methods like `some` / `every` were not used to avoid incurring the garbage\n    // cost of anonymous callbacks.\n    while(index-- > 0){\n        property = properties[index];\n        if (!isPropertyEqual(a, b, state, property)) {\n            return false;\n        }\n        descriptorA = getOwnPropertyDescriptor(a, property);\n        descriptorB = getOwnPropertyDescriptor(b, property);\n        if ((descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the primitive wrappers passed are equal in value.\n */ function arePrimitiveWrappersEqual(a, b) {\n    return sameValueZeroEqual(a.valueOf(), b.valueOf());\n}\n/**\n * Whether the regexps passed are equal in value.\n */ function areRegExpsEqual(a, b) {\n    return a.source === b.source && a.flags === b.flags;\n}\n/**\n * Whether the `Set`s are equal in value.\n */ function areSetsEqual(a, b, state) {\n    var size = a.size;\n    if (size !== b.size) {\n        return false;\n    }\n    if (!size) {\n        return true;\n    }\n    var matchedIndices = new Array(size);\n    var aIterable = a.values();\n    var aResult;\n    var bResult;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    while(aResult = aIterable.next()){\n        if (aResult.done) {\n            break;\n        }\n        var bIterable = b.values();\n        var hasMatch = false;\n        var matchIndex = 0;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        while(bResult = bIterable.next()){\n            if (bResult.done) {\n                break;\n            }\n            if (!matchedIndices[matchIndex] && state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state)) {\n                hasMatch = matchedIndices[matchIndex] = true;\n                break;\n            }\n            matchIndex++;\n        }\n        if (!hasMatch) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the TypedArray instances are equal in value.\n */ function areTypedArraysEqual(a, b) {\n    var index = a.length;\n    if (b.length !== index) {\n        return false;\n    }\n    while(index-- > 0){\n        if (a[index] !== b[index]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the URL instances are equal in value.\n */ function areUrlsEqual(a, b) {\n    return a.hostname === b.hostname && a.pathname === b.pathname && a.protocol === b.protocol && a.port === b.port && a.hash === b.hash && a.username === b.username && a.password === b.password;\n}\nfunction isPropertyEqual(a, b, state, property) {\n    if ((property === REACT_OWNER || property === PREACT_OWNER || property === PREACT_VNODE) && (a.$$typeof || b.$$typeof)) {\n        return true;\n    }\n    return hasOwn(b, property) && state.equals(a[property], b[property], property, property, a, b, state);\n}\nvar ARGUMENTS_TAG = \"[object Arguments]\";\nvar BOOLEAN_TAG = \"[object Boolean]\";\nvar DATE_TAG = \"[object Date]\";\nvar ERROR_TAG = \"[object Error]\";\nvar MAP_TAG = \"[object Map]\";\nvar NUMBER_TAG = \"[object Number]\";\nvar OBJECT_TAG = \"[object Object]\";\nvar REG_EXP_TAG = \"[object RegExp]\";\nvar SET_TAG = \"[object Set]\";\nvar STRING_TAG = \"[object String]\";\nvar URL_TAG = \"[object URL]\";\nvar isArray = Array.isArray;\nvar isTypedArray = typeof ArrayBuffer !== \"undefined\" && typeof ArrayBuffer.isView === \"function\" ? ArrayBuffer.isView : null;\nvar assign = Object.assign;\nvar getTag = Object.prototype.toString.call.bind(Object.prototype.toString);\n/**\n * Create a comparator method based on the type-specific equality comparators passed.\n */ function createEqualityComparator(_a) {\n    var areArraysEqual = _a.areArraysEqual, areDatesEqual = _a.areDatesEqual, areErrorsEqual = _a.areErrorsEqual, areFunctionsEqual = _a.areFunctionsEqual, areMapsEqual = _a.areMapsEqual, areNumbersEqual = _a.areNumbersEqual, areObjectsEqual = _a.areObjectsEqual, arePrimitiveWrappersEqual = _a.arePrimitiveWrappersEqual, areRegExpsEqual = _a.areRegExpsEqual, areSetsEqual = _a.areSetsEqual, areTypedArraysEqual = _a.areTypedArraysEqual, areUrlsEqual = _a.areUrlsEqual, unknownTagComparators = _a.unknownTagComparators;\n    /**\n     * compare the value of the two objects and return true if they are equivalent in values\n     */ return function comparator(a, b, state) {\n        // If the items are strictly equal, no need to do a value comparison.\n        if (a === b) {\n            return true;\n        }\n        // If either of the items are nullish and fail the strictly equal check\n        // above, then they must be unequal.\n        if (a == null || b == null) {\n            return false;\n        }\n        var type = typeof a;\n        if (type !== typeof b) {\n            return false;\n        }\n        if (type !== \"object\") {\n            if (type === \"number\") {\n                return areNumbersEqual(a, b, state);\n            }\n            if (type === \"function\") {\n                return areFunctionsEqual(a, b, state);\n            }\n            // If a primitive value that is not strictly equal, it must be unequal.\n            return false;\n        }\n        var constructor = a.constructor;\n        // Checks are listed in order of commonality of use-case:\n        //   1. Common complex object types (plain object, array)\n        //   2. Common data values (date, regexp)\n        //   3. Less-common complex object types (map, set)\n        //   4. Less-common data values (promise, primitive wrappers)\n        // Inherently this is both subjective and assumptive, however\n        // when reviewing comparable libraries in the wild this order\n        // appears to be generally consistent.\n        // Constructors should match, otherwise there is potential for false positives\n        // between class and subclass or custom object and POJO.\n        if (constructor !== b.constructor) {\n            return false;\n        }\n        // `isPlainObject` only checks against the object's own realm. Cross-realm\n        // comparisons are rare, and will be handled in the ultimate fallback, so\n        // we can avoid capturing the string tag.\n        if (constructor === Object) {\n            return areObjectsEqual(a, b, state);\n        }\n        // `isArray()` works on subclasses and is cross-realm, so we can avoid capturing\n        // the string tag or doing an `instanceof` check.\n        if (isArray(a)) {\n            return areArraysEqual(a, b, state);\n        }\n        // `isTypedArray()` works on all possible TypedArray classes, so we can avoid\n        // capturing the string tag or comparing against all possible constructors.\n        if (isTypedArray != null && isTypedArray(a)) {\n            return areTypedArraysEqual(a, b, state);\n        }\n        // Try to fast-path equality checks for other complex object types in the\n        // same realm to avoid capturing the string tag. Strict equality is used\n        // instead of `instanceof` because it is more performant for the common\n        // use-case. If someone is subclassing a native class, it will be handled\n        // with the string tag comparison.\n        if (constructor === Date) {\n            return areDatesEqual(a, b, state);\n        }\n        if (constructor === RegExp) {\n            return areRegExpsEqual(a, b, state);\n        }\n        if (constructor === Map) {\n            return areMapsEqual(a, b, state);\n        }\n        if (constructor === Set) {\n            return areSetsEqual(a, b, state);\n        }\n        // Since this is a custom object, capture the string tag to determing its type.\n        // This is reasonably performant in modern environments like v8 and SpiderMonkey.\n        var tag = getTag(a);\n        if (tag === DATE_TAG) {\n            return areDatesEqual(a, b, state);\n        }\n        // For RegExp, the properties are not enumerable, and therefore will give false positives if\n        // tested like a standard object.\n        if (tag === REG_EXP_TAG) {\n            return areRegExpsEqual(a, b, state);\n        }\n        if (tag === MAP_TAG) {\n            return areMapsEqual(a, b, state);\n        }\n        if (tag === SET_TAG) {\n            return areSetsEqual(a, b, state);\n        }\n        if (tag === OBJECT_TAG) {\n            // The exception for value comparison is custom `Promise`-like class instances. These should\n            // be treated the same as standard `Promise` objects, which means strict equality, and if\n            // it reaches this point then that strict equality comparison has already failed.\n            return typeof a.then !== \"function\" && typeof b.then !== \"function\" && areObjectsEqual(a, b, state);\n        }\n        // If a URL tag, it should be tested explicitly. Like RegExp, the properties are not\n        // enumerable, and therefore will give false positives if tested like a standard object.\n        if (tag === URL_TAG) {\n            return areUrlsEqual(a, b, state);\n        }\n        // If an error tag, it should be tested explicitly. Like RegExp, the properties are not\n        // enumerable, and therefore will give false positives if tested like a standard object.\n        if (tag === ERROR_TAG) {\n            return areErrorsEqual(a, b, state);\n        }\n        // If an arguments tag, it should be treated as a standard object.\n        if (tag === ARGUMENTS_TAG) {\n            return areObjectsEqual(a, b, state);\n        }\n        // As the penultimate fallback, check if the values passed are primitive wrappers. This\n        // is very rare in modern JS, which is why it is deprioritized compared to all other object\n        // types.\n        if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {\n            return arePrimitiveWrappersEqual(a, b, state);\n        }\n        if (unknownTagComparators) {\n            var unknownTagComparator = unknownTagComparators[tag];\n            if (!unknownTagComparator) {\n                var shortTag = getShortTag(a);\n                if (shortTag) {\n                    unknownTagComparator = unknownTagComparators[shortTag];\n                }\n            }\n            // If the custom config has an unknown tag comparator that matches the captured tag or the\n            // @@toStringTag, it is the source of truth for whether the values are equal.\n            if (unknownTagComparator) {\n                return unknownTagComparator(a, b, state);\n            }\n        }\n        // If not matching any tags that require a specific type of comparison, then we hard-code false because\n        // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\n        //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\n        //     comparison that can be made.\n        //   - For types that can be introspected, but rarely have requirements to be compared\n        //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\n        //     use-cases (may be included in a future release, if requested enough).\n        //   - For types that can be introspected but do not have an objective definition of what\n        //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\n        // In all cases, these decisions should be reevaluated based on changes to the language and\n        // common development practices.\n        return false;\n    };\n}\n/**\n * Create the configuration object used for building comparators.\n */ function createEqualityComparatorConfig(_a) {\n    var circular = _a.circular, createCustomConfig = _a.createCustomConfig, strict = _a.strict;\n    var config = {\n        areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,\n        areDatesEqual: areDatesEqual,\n        areErrorsEqual: areErrorsEqual,\n        areFunctionsEqual: areFunctionsEqual,\n        areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,\n        areNumbersEqual: areNumbersEqual,\n        areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,\n        arePrimitiveWrappersEqual: arePrimitiveWrappersEqual,\n        areRegExpsEqual: areRegExpsEqual,\n        areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,\n        areTypedArraysEqual: strict ? areObjectsEqualStrict : areTypedArraysEqual,\n        areUrlsEqual: areUrlsEqual,\n        unknownTagComparators: undefined\n    };\n    if (createCustomConfig) {\n        config = assign({}, config, createCustomConfig(config));\n    }\n    if (circular) {\n        var areArraysEqual$1 = createIsCircular(config.areArraysEqual);\n        var areMapsEqual$1 = createIsCircular(config.areMapsEqual);\n        var areObjectsEqual$1 = createIsCircular(config.areObjectsEqual);\n        var areSetsEqual$1 = createIsCircular(config.areSetsEqual);\n        config = assign({}, config, {\n            areArraysEqual: areArraysEqual$1,\n            areMapsEqual: areMapsEqual$1,\n            areObjectsEqual: areObjectsEqual$1,\n            areSetsEqual: areSetsEqual$1\n        });\n    }\n    return config;\n}\n/**\n * Default equality comparator pass-through, used as the standard `isEqual` creator for\n * use inside the built comparator.\n */ function createInternalEqualityComparator(compare) {\n    return function(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {\n        return compare(a, b, state);\n    };\n}\n/**\n * Create the `isEqual` function used by the consuming application.\n */ function createIsEqual(_a) {\n    var circular = _a.circular, comparator = _a.comparator, createState = _a.createState, equals = _a.equals, strict = _a.strict;\n    if (createState) {\n        return function isEqual(a, b) {\n            var _a = createState(), _b = _a.cache, cache = _b === void 0 ? circular ? new WeakMap() : undefined : _b, meta = _a.meta;\n            return comparator(a, b, {\n                cache: cache,\n                equals: equals,\n                meta: meta,\n                strict: strict\n            });\n        };\n    }\n    if (circular) {\n        return function isEqual(a, b) {\n            return comparator(a, b, {\n                cache: new WeakMap(),\n                equals: equals,\n                meta: undefined,\n                strict: strict\n            });\n        };\n    }\n    var state = {\n        cache: undefined,\n        equals: equals,\n        meta: undefined,\n        strict: strict\n    };\n    return function isEqual(a, b) {\n        return comparator(a, b, state);\n    };\n}\n/**\n * Whether the items passed are deeply-equal in value.\n */ var deepEqual = createCustomEqual();\n/**\n * Whether the items passed are deeply-equal in value based on strict comparison.\n */ var strictDeepEqual = createCustomEqual({\n    strict: true\n});\n/**\n * Whether the items passed are deeply-equal in value, including circular references.\n */ var circularDeepEqual = createCustomEqual({\n    circular: true\n});\n/**\n * Whether the items passed are deeply-equal in value, including circular references,\n * based on strict comparison.\n */ var strictCircularDeepEqual = createCustomEqual({\n    circular: true,\n    strict: true\n});\n/**\n * Whether the items passed are shallowly-equal in value.\n */ var shallowEqual = createCustomEqual({\n    createInternalComparator: function() {\n        return sameValueZeroEqual;\n    }\n});\n/**\n * Whether the items passed are shallowly-equal in value based on strict comparison\n */ var strictShallowEqual = createCustomEqual({\n    strict: true,\n    createInternalComparator: function() {\n        return sameValueZeroEqual;\n    }\n});\n/**\n * Whether the items passed are shallowly-equal in value, including circular references.\n */ var circularShallowEqual = createCustomEqual({\n    circular: true,\n    createInternalComparator: function() {\n        return sameValueZeroEqual;\n    }\n});\n/**\n * Whether the items passed are shallowly-equal in value, including circular references,\n * based on strict comparison.\n */ var strictCircularShallowEqual = createCustomEqual({\n    circular: true,\n    createInternalComparator: function() {\n        return sameValueZeroEqual;\n    },\n    strict: true\n});\n/**\n * Create a custom equality comparison method.\n *\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\n * where the standard methods are not performant enough, but can also be used to provide\n * support for legacy environments that do not support expected features like\n * `RegExp.prototype.flags` out of the box.\n */ function createCustomEqual(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _a = options.circular, circular = _a === void 0 ? false : _a, createCustomInternalComparator = options.createInternalComparator, createState = options.createState, _b = options.strict, strict = _b === void 0 ? false : _b;\n    var config = createEqualityComparatorConfig(options);\n    var comparator = createEqualityComparator(config);\n    var equals = createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator);\n    return createIsEqual({\n        circular: circular,\n        comparator: comparator,\n        createState: createState,\n        equals: equals,\n        strict: strict\n    });\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC1lcXVhbHMvZGlzdC9lc20vaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxzQkFBc0JDLE9BQU9ELG1CQUFtQixFQUFFRSx3QkFBd0JELE9BQU9DLHFCQUFxQjtBQUMxRyxJQUFJQyxpQkFBaUJGLE9BQU9HLFNBQVMsQ0FBQ0QsY0FBYztBQUNwRDs7Q0FFQyxHQUNELFNBQVNFLG1CQUFtQkMsV0FBVyxFQUFFQyxXQUFXO0lBQ2hELE9BQU8sU0FBU0MsUUFBUUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEtBQUs7UUFDL0IsT0FBT0wsWUFBWUcsR0FBR0MsR0FBR0MsVUFBVUosWUFBWUUsR0FBR0MsR0FBR0M7SUFDekQ7QUFDSjtBQUNBOzs7O0NBSUMsR0FDRCxTQUFTQyxpQkFBaUJDLGFBQWE7SUFDbkMsT0FBTyxTQUFTQyxXQUFXTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsS0FBSztRQUNsQyxJQUFJLENBQUNGLEtBQUssQ0FBQ0MsS0FBSyxPQUFPRCxNQUFNLFlBQVksT0FBT0MsTUFBTSxVQUFVO1lBQzVELE9BQU9HLGNBQWNKLEdBQUdDLEdBQUdDO1FBQy9CO1FBQ0EsSUFBSUksUUFBUUosTUFBTUksS0FBSztRQUN2QixJQUFJQyxVQUFVRCxNQUFNRSxHQUFHLENBQUNSO1FBQ3hCLElBQUlTLFVBQVVILE1BQU1FLEdBQUcsQ0FBQ1A7UUFDeEIsSUFBSU0sV0FBV0UsU0FBUztZQUNwQixPQUFPRixZQUFZTixLQUFLUSxZQUFZVDtRQUN4QztRQUNBTSxNQUFNSSxHQUFHLENBQUNWLEdBQUdDO1FBQ2JLLE1BQU1JLEdBQUcsQ0FBQ1QsR0FBR0Q7UUFDYixJQUFJVyxTQUFTUCxjQUFjSixHQUFHQyxHQUFHQztRQUNqQ0ksTUFBTU0sTUFBTSxDQUFDWjtRQUNiTSxNQUFNTSxNQUFNLENBQUNYO1FBQ2IsT0FBT1U7SUFDWDtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxTQUFTRSxZQUFZQyxLQUFL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QyxHQUNELFNBQVNrQixrQkFBa0JTLE9BQU87SUFDOUIsSUFBSUEsWUFBWSxLQUFLLEdBQUc7UUFBRUEsVUFBVSxDQUFDO0lBQUc7SUFDeEMsSUFBSTNDLEtBQUsyQyxRQUFRN0IsUUFBUSxFQUFFQSxXQUFXZCxPQUFPLEtBQUssSUFBSSxRQUFRQSxJQUFJNEMsaUNBQWlDRCxRQUFRSix3QkFBd0IsRUFBRVYsY0FBY2MsUUFBUWQsV0FBVyxFQUFFQyxLQUFLYSxRQUFRM0IsTUFBTSxFQUFFQSxTQUFTYyxPQUFPLEtBQUssSUFBSSxRQUFRQTtJQUM5TixJQUFJYixTQUFTSiwrQkFBK0I4QjtJQUM1QyxJQUFJekMsYUFBYUgseUJBQXlCa0I7SUFDMUMsSUFBSXhGLFNBQVNtSCxpQ0FDUEEsK0JBQStCMUMsY0FDL0JvQixpQ0FBaUNwQjtJQUN2QyxPQUFPMEIsY0FBYztRQUFFZCxVQUFVQTtRQUFVWixZQUFZQTtRQUFZMkIsYUFBYUE7UUFBYXBHLFFBQVFBO1FBQVF1RixRQUFRQTtJQUFPO0FBQ2hJO0FBRTZNLENBQzdNLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3doYXRzYXBwLWJ1c2luZXNzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9mYXN0LWVxdWFscy9kaXN0L2VzbS9pbmRleC5tanM/MTBkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbi8qKlxuICogQ29tYmluZSB0d28gY29tcGFyYXRvcnMgaW50byBhIHNpbmdsZSBjb21wYXJhdG9ycy5cbiAqL1xuZnVuY3Rpb24gY29tYmluZUNvbXBhcmF0b3JzKGNvbXBhcmF0b3JBLCBjb21wYXJhdG9yQikge1xuICAgIHJldHVybiBmdW5jdGlvbiBpc0VxdWFsKGEsIGIsIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJhdG9yQShhLCBiLCBzdGF0ZSkgJiYgY29tcGFyYXRvckIoYSwgYiwgc3RhdGUpO1xuICAgIH07XG59XG4vKipcbiAqIFdyYXAgdGhlIHByb3ZpZGVkIGBhcmVJdGVtc0VxdWFsYCBtZXRob2QgdG8gbWFuYWdlIHRoZSBjaXJjdWxhciBzdGF0ZSwgYWxsb3dpbmdcbiAqIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIHRvIGJlIHNhZmVseSBpbmNsdWRlZCBpbiB0aGUgY29tcGFyaXNvbiB3aXRob3V0IGNyZWF0aW5nXG4gKiBzdGFjayBvdmVyZmxvd3MuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlzQ2lyY3VsYXIoYXJlSXRlbXNFcXVhbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBpc0NpcmN1bGFyKGEsIGIsIHN0YXRlKSB7XG4gICAgICAgIGlmICghYSB8fCAhYiB8fCB0eXBlb2YgYSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlSXRlbXNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhY2hlID0gc3RhdGUuY2FjaGU7XG4gICAgICAgIHZhciBjYWNoZWRBID0gY2FjaGUuZ2V0KGEpO1xuICAgICAgICB2YXIgY2FjaGVkQiA9IGNhY2hlLmdldChiKTtcbiAgICAgICAgaWYgKGNhY2hlZEEgJiYgY2FjaGVkQikge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZEEgPT09IGIgJiYgY2FjaGVkQiA9PT0gYTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZS5zZXQoYSwgYik7XG4gICAgICAgIGNhY2hlLnNldChiLCBhKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGFyZUl0ZW1zRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICBjYWNoZS5kZWxldGUoYSk7XG4gICAgICAgIGNhY2hlLmRlbGV0ZShiKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuLyoqXG4gKiBHZXQgdGhlIGBAQHRvU3RyaW5nVGFnYCBvZiB0aGUgdmFsdWUsIGlmIGl0IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gZ2V0U2hvcnRUYWcodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gOiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIEdldCB0aGUgcHJvcGVydGllcyB0byBzdHJpY3RseSBleGFtaW5lLCB3aGljaCBpbmNsdWRlIGJvdGggb3duIHByb3BlcnRpZXMgdGhhdCBhcmVcbiAqIG5vdCBlbnVtZXJhYmxlIGFuZCBzeW1ib2wgcHJvcGVydGllcy5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RyaWN0UHJvcGVydGllcyhvYmplY3QpIHtcbiAgICByZXR1cm4gZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KSk7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIG9iamVjdCBjb250YWlucyB0aGUgcHJvcGVydHkgcGFzc2VkIGFzIGFuIG93biBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093biA9IFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbk9iamVjdC5oYXNPd24gfHxcbiAgICAoZnVuY3Rpb24gKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7XG4gICAgfSk7XG4vKipcbiAqIFdoZXRoZXIgdGhlIHZhbHVlcyBwYXNzZWQgYXJlIHN0cmljdGx5IGVxdWFsIG9yIGJvdGggTmFOLlxuICovXG5mdW5jdGlvbiBzYW1lVmFsdWVaZXJvRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhID09PSBiIHx8ICghYSAmJiAhYiAmJiBhICE9PSBhICYmIGIgIT09IGIpO1xufVxuXG52YXIgUFJFQUNUX1ZOT0RFID0gJ19fdic7XG52YXIgUFJFQUNUX09XTkVSID0gJ19fbyc7XG52YXIgUkVBQ1RfT1dORVIgPSAnX293bmVyJztcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLCBrZXlzID0gT2JqZWN0LmtleXM7XG4vKipcbiAqIFdoZXRoZXIgdGhlIGFycmF5cyBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFyZUFycmF5c0VxdWFsKGEsIGIsIHN0YXRlKSB7XG4gICAgdmFyIGluZGV4ID0gYS5sZW5ndGg7XG4gICAgaWYgKGIubGVuZ3RoICE9PSBpbmRleCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHdoaWxlIChpbmRleC0tID4gMCkge1xuICAgICAgICBpZiAoIXN0YXRlLmVxdWFscyhhW2luZGV4XSwgYltpbmRleF0sIGluZGV4LCBpbmRleCwgYSwgYiwgc3RhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIGRhdGVzIHBhc3NlZCBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFyZURhdGVzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBzYW1lVmFsdWVaZXJvRXF1YWwoYS5nZXRUaW1lKCksIGIuZ2V0VGltZSgpKTtcbn1cbi8qKlxuICogV2hldGhlciB0aGUgZXJyb3JzIHBhc3NlZCBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFyZUVycm9yc0VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gKGEubmFtZSA9PT0gYi5uYW1lICYmXG4gICAgICAgIGEubWVzc2FnZSA9PT0gYi5tZXNzYWdlICYmXG4gICAgICAgIGEuY2F1c2UgPT09IGIuY2F1c2UgJiZcbiAgICAgICAgYS5zdGFjayA9PT0gYi5zdGFjayk7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIGZ1bmN0aW9ucyBwYXNzZWQgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVGdW5jdGlvbnNFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIGBNYXBgcyBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFyZU1hcHNFcXVhbChhLCBiLCBzdGF0ZSkge1xuICAgIHZhciBzaXplID0gYS5zaXplO1xuICAgIGlmIChzaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBtYXRjaGVkSW5kaWNlcyA9IG5ldyBBcnJheShzaXplKTtcbiAgICB2YXIgYUl0ZXJhYmxlID0gYS5lbnRyaWVzKCk7XG4gICAgdmFyIGFSZXN1bHQ7XG4gICAgdmFyIGJSZXN1bHQ7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgIHdoaWxlICgoYVJlc3VsdCA9IGFJdGVyYWJsZS5uZXh0KCkpKSB7XG4gICAgICAgIGlmIChhUmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiSXRlcmFibGUgPSBiLmVudHJpZXMoKTtcbiAgICAgICAgdmFyIGhhc01hdGNoID0gZmFsc2U7XG4gICAgICAgIHZhciBtYXRjaEluZGV4ID0gMDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgd2hpbGUgKChiUmVzdWx0ID0gYkl0ZXJhYmxlLm5leHQoKSkpIHtcbiAgICAgICAgICAgIGlmIChiUmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGVkSW5kaWNlc1ttYXRjaEluZGV4XSkge1xuICAgICAgICAgICAgICAgIG1hdGNoSW5kZXgrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhRW50cnkgPSBhUmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgdmFyIGJFbnRyeSA9IGJSZXN1bHQudmFsdWU7XG4gICAgICAgICAgICBpZiAoc3RhdGUuZXF1YWxzKGFFbnRyeVswXSwgYkVudHJ5WzBdLCBpbmRleCwgbWF0Y2hJbmRleCwgYSwgYiwgc3RhdGUpICYmXG4gICAgICAgICAgICAgICAgc3RhdGUuZXF1YWxzKGFFbnRyeVsxXSwgYkVudHJ5WzFdLCBhRW50cnlbMF0sIGJFbnRyeVswXSwgYSwgYiwgc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSBtYXRjaGVkSW5kaWNlc1ttYXRjaEluZGV4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRjaEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNNYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4Kys7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBudW1iZXJzIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xudmFyIGFyZU51bWJlcnNFcXVhbCA9IHNhbWVWYWx1ZVplcm9FcXVhbDtcbi8qKlxuICogV2hldGhlciB0aGUgb2JqZWN0cyBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFyZU9iamVjdHNFcXVhbChhLCBiLCBzdGF0ZSkge1xuICAgIHZhciBwcm9wZXJ0aWVzID0ga2V5cyhhKTtcbiAgICB2YXIgaW5kZXggPSBwcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICBpZiAoa2V5cyhiKS5sZW5ndGggIT09IGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gRGVjcmVtZW50aW5nIGB3aGlsZWAgc2hvd2VkIGZhc3RlciByZXN1bHRzIHRoYW4gZWl0aGVyIGluY3JlbWVudGluZyBvclxuICAgIC8vIGRlY3JlbWVudGluZyBgZm9yYCBsb29wIGFuZCB0aGFuIGFuIGluY3JlbWVudGluZyBgd2hpbGVgIGxvb3AuIERlY2xhcmF0aXZlXG4gICAgLy8gbWV0aG9kcyBsaWtlIGBzb21lYCAvIGBldmVyeWAgd2VyZSBub3QgdXNlZCB0byBhdm9pZCBpbmN1cnJpbmcgdGhlIGdhcmJhZ2VcbiAgICAvLyBjb3N0IG9mIGFub255bW91cyBjYWxsYmFja3MuXG4gICAgd2hpbGUgKGluZGV4LS0gPiAwKSB7XG4gICAgICAgIGlmICghaXNQcm9wZXJ0eUVxdWFsKGEsIGIsIHN0YXRlLCBwcm9wZXJ0aWVzW2luZGV4XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogV2hldGhlciB0aGUgb2JqZWN0cyBhcmUgZXF1YWwgaW4gdmFsdWUgd2l0aCBzdHJpY3QgcHJvcGVydHkgY2hlY2tpbmcuXG4gKi9cbmZ1bmN0aW9uIGFyZU9iamVjdHNFcXVhbFN0cmljdChhLCBiLCBzdGF0ZSkge1xuICAgIHZhciBwcm9wZXJ0aWVzID0gZ2V0U3RyaWN0UHJvcGVydGllcyhhKTtcbiAgICB2YXIgaW5kZXggPSBwcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICBpZiAoZ2V0U3RyaWN0UHJvcGVydGllcyhiKS5sZW5ndGggIT09IGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHByb3BlcnR5O1xuICAgIHZhciBkZXNjcmlwdG9yQTtcbiAgICB2YXIgZGVzY3JpcHRvckI7XG4gICAgLy8gRGVjcmVtZW50aW5nIGB3aGlsZWAgc2hvd2VkIGZhc3RlciByZXN1bHRzIHRoYW4gZWl0aGVyIGluY3JlbWVudGluZyBvclxuICAgIC8vIGRlY3JlbWVudGluZyBgZm9yYCBsb29wIGFuZCB0aGFuIGFuIGluY3JlbWVudGluZyBgd2hpbGVgIGxvb3AuIERlY2xhcmF0aXZlXG4gICAgLy8gbWV0aG9kcyBsaWtlIGBzb21lYCAvIGBldmVyeWAgd2VyZSBub3QgdXNlZCB0byBhdm9pZCBpbmN1cnJpbmcgdGhlIGdhcmJhZ2VcbiAgICAvLyBjb3N0IG9mIGFub255bW91cyBjYWxsYmFja3MuXG4gICAgd2hpbGUgKGluZGV4LS0gPiAwKSB7XG4gICAgICAgIHByb3BlcnR5ID0gcHJvcGVydGllc1tpbmRleF07XG4gICAgICAgIGlmICghaXNQcm9wZXJ0eUVxdWFsKGEsIGIsIHN0YXRlLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBkZXNjcmlwdG9yQSA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihhLCBwcm9wZXJ0eSk7XG4gICAgICAgIGRlc2NyaXB0b3JCID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGIsIHByb3BlcnR5KTtcbiAgICAgICAgaWYgKChkZXNjcmlwdG9yQSB8fCBkZXNjcmlwdG9yQikgJiZcbiAgICAgICAgICAgICghZGVzY3JpcHRvckEgfHxcbiAgICAgICAgICAgICAgICAhZGVzY3JpcHRvckIgfHxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yQS5jb25maWd1cmFibGUgIT09IGRlc2NyaXB0b3JCLmNvbmZpZ3VyYWJsZSB8fFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3JBLmVudW1lcmFibGUgIT09IGRlc2NyaXB0b3JCLmVudW1lcmFibGUgfHxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yQS53cml0YWJsZSAhPT0gZGVzY3JpcHRvckIud3JpdGFibGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIHByaW1pdGl2ZSB3cmFwcGVycyBwYXNzZWQgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVQcmltaXRpdmVXcmFwcGVyc0VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gc2FtZVZhbHVlWmVyb0VxdWFsKGEudmFsdWVPZigpLCBiLnZhbHVlT2YoKSk7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIHJlZ2V4cHMgcGFzc2VkIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJlUmVnRXhwc0VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIGBTZXRgcyBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFyZVNldHNFcXVhbChhLCBiLCBzdGF0ZSkge1xuICAgIHZhciBzaXplID0gYS5zaXplO1xuICAgIGlmIChzaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBtYXRjaGVkSW5kaWNlcyA9IG5ldyBBcnJheShzaXplKTtcbiAgICB2YXIgYUl0ZXJhYmxlID0gYS52YWx1ZXMoKTtcbiAgICB2YXIgYVJlc3VsdDtcbiAgICB2YXIgYlJlc3VsdDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgIHdoaWxlICgoYVJlc3VsdCA9IGFJdGVyYWJsZS5uZXh0KCkpKSB7XG4gICAgICAgIGlmIChhUmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiSXRlcmFibGUgPSBiLnZhbHVlcygpO1xuICAgICAgICB2YXIgaGFzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgdmFyIG1hdGNoSW5kZXggPSAwO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICB3aGlsZSAoKGJSZXN1bHQgPSBiSXRlcmFibGUubmV4dCgpKSkge1xuICAgICAgICAgICAgaWYgKGJSZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtYXRjaGVkSW5kaWNlc1ttYXRjaEluZGV4XSAmJlxuICAgICAgICAgICAgICAgIHN0YXRlLmVxdWFscyhhUmVzdWx0LnZhbHVlLCBiUmVzdWx0LnZhbHVlLCBhUmVzdWx0LnZhbHVlLCBiUmVzdWx0LnZhbHVlLCBhLCBiLCBzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBoYXNNYXRjaCA9IG1hdGNoZWRJbmRpY2VzW21hdGNoSW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGNoSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc01hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIFR5cGVkQXJyYXkgaW5zdGFuY2VzIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJlVHlwZWRBcnJheXNFcXVhbChhLCBiKSB7XG4gICAgdmFyIGluZGV4ID0gYS5sZW5ndGg7XG4gICAgaWYgKGIubGVuZ3RoICE9PSBpbmRleCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHdoaWxlIChpbmRleC0tID4gMCkge1xuICAgICAgICBpZiAoYVtpbmRleF0gIT09IGJbaW5kZXhdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIFVSTCBpbnN0YW5jZXMgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVVcmxzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiAoYS5ob3N0bmFtZSA9PT0gYi5ob3N0bmFtZSAmJlxuICAgICAgICBhLnBhdGhuYW1lID09PSBiLnBhdGhuYW1lICYmXG4gICAgICAgIGEucHJvdG9jb2wgPT09IGIucHJvdG9jb2wgJiZcbiAgICAgICAgYS5wb3J0ID09PSBiLnBvcnQgJiZcbiAgICAgICAgYS5oYXNoID09PSBiLmhhc2ggJiZcbiAgICAgICAgYS51c2VybmFtZSA9PT0gYi51c2VybmFtZSAmJlxuICAgICAgICBhLnBhc3N3b3JkID09PSBiLnBhc3N3b3JkKTtcbn1cbmZ1bmN0aW9uIGlzUHJvcGVydHlFcXVhbChhLCBiLCBzdGF0ZSwgcHJvcGVydHkpIHtcbiAgICBpZiAoKHByb3BlcnR5ID09PSBSRUFDVF9PV05FUiB8fFxuICAgICAgICBwcm9wZXJ0eSA9PT0gUFJFQUNUX09XTkVSIHx8XG4gICAgICAgIHByb3BlcnR5ID09PSBQUkVBQ1RfVk5PREUpICYmXG4gICAgICAgIChhLiQkdHlwZW9mIHx8IGIuJCR0eXBlb2YpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gKGhhc093bihiLCBwcm9wZXJ0eSkgJiZcbiAgICAgICAgc3RhdGUuZXF1YWxzKGFbcHJvcGVydHldLCBiW3Byb3BlcnR5XSwgcHJvcGVydHksIHByb3BlcnR5LCBhLCBiLCBzdGF0ZSkpO1xufVxuXG52YXIgQVJHVU1FTlRTX1RBRyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xudmFyIEJPT0xFQU5fVEFHID0gJ1tvYmplY3QgQm9vbGVhbl0nO1xudmFyIERBVEVfVEFHID0gJ1tvYmplY3QgRGF0ZV0nO1xudmFyIEVSUk9SX1RBRyA9ICdbb2JqZWN0IEVycm9yXSc7XG52YXIgTUFQX1RBRyA9ICdbb2JqZWN0IE1hcF0nO1xudmFyIE5VTUJFUl9UQUcgPSAnW29iamVjdCBOdW1iZXJdJztcbnZhciBPQkpFQ1RfVEFHID0gJ1tvYmplY3QgT2JqZWN0XSc7XG52YXIgUkVHX0VYUF9UQUcgPSAnW29iamVjdCBSZWdFeHBdJztcbnZhciBTRVRfVEFHID0gJ1tvYmplY3QgU2V0XSc7XG52YXIgU1RSSU5HX1RBRyA9ICdbb2JqZWN0IFN0cmluZ10nO1xudmFyIFVSTF9UQUcgPSAnW29iamVjdCBVUkxdJztcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbnZhciBpc1R5cGVkQXJyYXkgPSB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbidcbiAgICA/IEFycmF5QnVmZmVyLmlzVmlld1xuICAgIDogbnVsbDtcbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xudmFyIGdldFRhZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuLyoqXG4gKiBDcmVhdGUgYSBjb21wYXJhdG9yIG1ldGhvZCBiYXNlZCBvbiB0aGUgdHlwZS1zcGVjaWZpYyBlcXVhbGl0eSBjb21wYXJhdG9ycyBwYXNzZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVxdWFsaXR5Q29tcGFyYXRvcihfYSkge1xuICAgIHZhciBhcmVBcnJheXNFcXVhbCA9IF9hLmFyZUFycmF5c0VxdWFsLCBhcmVEYXRlc0VxdWFsID0gX2EuYXJlRGF0ZXNFcXVhbCwgYXJlRXJyb3JzRXF1YWwgPSBfYS5hcmVFcnJvcnNFcXVhbCwgYXJlRnVuY3Rpb25zRXF1YWwgPSBfYS5hcmVGdW5jdGlvbnNFcXVhbCwgYXJlTWFwc0VxdWFsID0gX2EuYXJlTWFwc0VxdWFsLCBhcmVOdW1iZXJzRXF1YWwgPSBfYS5hcmVOdW1iZXJzRXF1YWwsIGFyZU9iamVjdHNFcXVhbCA9IF9hLmFyZU9iamVjdHNFcXVhbCwgYXJlUHJpbWl0aXZlV3JhcHBlcnNFcXVhbCA9IF9hLmFyZVByaW1pdGl2ZVdyYXBwZXJzRXF1YWwsIGFyZVJlZ0V4cHNFcXVhbCA9IF9hLmFyZVJlZ0V4cHNFcXVhbCwgYXJlU2V0c0VxdWFsID0gX2EuYXJlU2V0c0VxdWFsLCBhcmVUeXBlZEFycmF5c0VxdWFsID0gX2EuYXJlVHlwZWRBcnJheXNFcXVhbCwgYXJlVXJsc0VxdWFsID0gX2EuYXJlVXJsc0VxdWFsLCB1bmtub3duVGFnQ29tcGFyYXRvcnMgPSBfYS51bmtub3duVGFnQ29tcGFyYXRvcnM7XG4gICAgLyoqXG4gICAgICogY29tcGFyZSB0aGUgdmFsdWUgb2YgdGhlIHR3byBvYmplY3RzIGFuZCByZXR1cm4gdHJ1ZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50IGluIHZhbHVlc1xuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiBjb21wYXJhdG9yKGEsIGIsIHN0YXRlKSB7XG4gICAgICAgIC8vIElmIHRoZSBpdGVtcyBhcmUgc3RyaWN0bHkgZXF1YWwsIG5vIG5lZWQgdG8gZG8gYSB2YWx1ZSBjb21wYXJpc29uLlxuICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgZWl0aGVyIG9mIHRoZSBpdGVtcyBhcmUgbnVsbGlzaCBhbmQgZmFpbCB0aGUgc3RyaWN0bHkgZXF1YWwgY2hlY2tcbiAgICAgICAgLy8gYWJvdmUsIHRoZW4gdGhleSBtdXN0IGJlIHVuZXF1YWwuXG4gICAgICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgYTtcbiAgICAgICAgaWYgKHR5cGUgIT09IHR5cGVvZiBiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJlTnVtYmVyc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZUZ1bmN0aW9uc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGEgcHJpbWl0aXZlIHZhbHVlIHRoYXQgaXMgbm90IHN0cmljdGx5IGVxdWFsLCBpdCBtdXN0IGJlIHVuZXF1YWwuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gYS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgLy8gQ2hlY2tzIGFyZSBsaXN0ZWQgaW4gb3JkZXIgb2YgY29tbW9uYWxpdHkgb2YgdXNlLWNhc2U6XG4gICAgICAgIC8vICAgMS4gQ29tbW9uIGNvbXBsZXggb2JqZWN0IHR5cGVzIChwbGFpbiBvYmplY3QsIGFycmF5KVxuICAgICAgICAvLyAgIDIuIENvbW1vbiBkYXRhIHZhbHVlcyAoZGF0ZSwgcmVnZXhwKVxuICAgICAgICAvLyAgIDMuIExlc3MtY29tbW9uIGNvbXBsZXggb2JqZWN0IHR5cGVzIChtYXAsIHNldClcbiAgICAgICAgLy8gICA0LiBMZXNzLWNvbW1vbiBkYXRhIHZhbHVlcyAocHJvbWlzZSwgcHJpbWl0aXZlIHdyYXBwZXJzKVxuICAgICAgICAvLyBJbmhlcmVudGx5IHRoaXMgaXMgYm90aCBzdWJqZWN0aXZlIGFuZCBhc3N1bXB0aXZlLCBob3dldmVyXG4gICAgICAgIC8vIHdoZW4gcmV2aWV3aW5nIGNvbXBhcmFibGUgbGlicmFyaWVzIGluIHRoZSB3aWxkIHRoaXMgb3JkZXJcbiAgICAgICAgLy8gYXBwZWFycyB0byBiZSBnZW5lcmFsbHkgY29uc2lzdGVudC5cbiAgICAgICAgLy8gQ29uc3RydWN0b3JzIHNob3VsZCBtYXRjaCwgb3RoZXJ3aXNlIHRoZXJlIGlzIHBvdGVudGlhbCBmb3IgZmFsc2UgcG9zaXRpdmVzXG4gICAgICAgIC8vIGJldHdlZW4gY2xhc3MgYW5kIHN1YmNsYXNzIG9yIGN1c3RvbSBvYmplY3QgYW5kIFBPSk8uXG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGBpc1BsYWluT2JqZWN0YCBvbmx5IGNoZWNrcyBhZ2FpbnN0IHRoZSBvYmplY3QncyBvd24gcmVhbG0uIENyb3NzLXJlYWxtXG4gICAgICAgIC8vIGNvbXBhcmlzb25zIGFyZSByYXJlLCBhbmQgd2lsbCBiZSBoYW5kbGVkIGluIHRoZSB1bHRpbWF0ZSBmYWxsYmFjaywgc29cbiAgICAgICAgLy8gd2UgY2FuIGF2b2lkIGNhcHR1cmluZyB0aGUgc3RyaW5nIHRhZy5cbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVPYmplY3RzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGBpc0FycmF5KClgIHdvcmtzIG9uIHN1YmNsYXNzZXMgYW5kIGlzIGNyb3NzLXJlYWxtLCBzbyB3ZSBjYW4gYXZvaWQgY2FwdHVyaW5nXG4gICAgICAgIC8vIHRoZSBzdHJpbmcgdGFnIG9yIGRvaW5nIGFuIGBpbnN0YW5jZW9mYCBjaGVjay5cbiAgICAgICAgaWYgKGlzQXJyYXkoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVBcnJheXNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYGlzVHlwZWRBcnJheSgpYCB3b3JrcyBvbiBhbGwgcG9zc2libGUgVHlwZWRBcnJheSBjbGFzc2VzLCBzbyB3ZSBjYW4gYXZvaWRcbiAgICAgICAgLy8gY2FwdHVyaW5nIHRoZSBzdHJpbmcgdGFnIG9yIGNvbXBhcmluZyBhZ2FpbnN0IGFsbCBwb3NzaWJsZSBjb25zdHJ1Y3RvcnMuXG4gICAgICAgIGlmIChpc1R5cGVkQXJyYXkgIT0gbnVsbCAmJiBpc1R5cGVkQXJyYXkoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVUeXBlZEFycmF5c0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gZmFzdC1wYXRoIGVxdWFsaXR5IGNoZWNrcyBmb3Igb3RoZXIgY29tcGxleCBvYmplY3QgdHlwZXMgaW4gdGhlXG4gICAgICAgIC8vIHNhbWUgcmVhbG0gdG8gYXZvaWQgY2FwdHVyaW5nIHRoZSBzdHJpbmcgdGFnLiBTdHJpY3QgZXF1YWxpdHkgaXMgdXNlZFxuICAgICAgICAvLyBpbnN0ZWFkIG9mIGBpbnN0YW5jZW9mYCBiZWNhdXNlIGl0IGlzIG1vcmUgcGVyZm9ybWFudCBmb3IgdGhlIGNvbW1vblxuICAgICAgICAvLyB1c2UtY2FzZS4gSWYgc29tZW9uZSBpcyBzdWJjbGFzc2luZyBhIG5hdGl2ZSBjbGFzcywgaXQgd2lsbCBiZSBoYW5kbGVkXG4gICAgICAgIC8vIHdpdGggdGhlIHN0cmluZyB0YWcgY29tcGFyaXNvbi5cbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09PSBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlRGF0ZXNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09PSBSZWdFeHApIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVSZWdFeHBzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gTWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlTWFwc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc3RydWN0b3IgPT09IFNldCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZVNldHNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBhIGN1c3RvbSBvYmplY3QsIGNhcHR1cmUgdGhlIHN0cmluZyB0YWcgdG8gZGV0ZXJtaW5nIGl0cyB0eXBlLlxuICAgICAgICAvLyBUaGlzIGlzIHJlYXNvbmFibHkgcGVyZm9ybWFudCBpbiBtb2Rlcm4gZW52aXJvbm1lbnRzIGxpa2UgdjggYW5kIFNwaWRlck1vbmtleS5cbiAgICAgICAgdmFyIHRhZyA9IGdldFRhZyhhKTtcbiAgICAgICAgaWYgKHRhZyA9PT0gREFURV9UQUcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVEYXRlc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgUmVnRXhwLCB0aGUgcHJvcGVydGllcyBhcmUgbm90IGVudW1lcmFibGUsIGFuZCB0aGVyZWZvcmUgd2lsbCBnaXZlIGZhbHNlIHBvc2l0aXZlcyBpZlxuICAgICAgICAvLyB0ZXN0ZWQgbGlrZSBhIHN0YW5kYXJkIG9iamVjdC5cbiAgICAgICAgaWYgKHRhZyA9PT0gUkVHX0VYUF9UQUcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVSZWdFeHBzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT09IE1BUF9UQUcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVNYXBzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT09IFNFVF9UQUcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVTZXRzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT09IE9CSkVDVF9UQUcpIHtcbiAgICAgICAgICAgIC8vIFRoZSBleGNlcHRpb24gZm9yIHZhbHVlIGNvbXBhcmlzb24gaXMgY3VzdG9tIGBQcm9taXNlYC1saWtlIGNsYXNzIGluc3RhbmNlcy4gVGhlc2Ugc2hvdWxkXG4gICAgICAgICAgICAvLyBiZSB0cmVhdGVkIHRoZSBzYW1lIGFzIHN0YW5kYXJkIGBQcm9taXNlYCBvYmplY3RzLCB3aGljaCBtZWFucyBzdHJpY3QgZXF1YWxpdHksIGFuZCBpZlxuICAgICAgICAgICAgLy8gaXQgcmVhY2hlcyB0aGlzIHBvaW50IHRoZW4gdGhhdCBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbiBoYXMgYWxyZWFkeSBmYWlsZWQuXG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiBhLnRoZW4gIT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgYi50aGVuICE9PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICAgYXJlT2JqZWN0c0VxdWFsKGEsIGIsIHN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYSBVUkwgdGFnLCBpdCBzaG91bGQgYmUgdGVzdGVkIGV4cGxpY2l0bHkuIExpa2UgUmVnRXhwLCB0aGUgcHJvcGVydGllcyBhcmUgbm90XG4gICAgICAgIC8vIGVudW1lcmFibGUsIGFuZCB0aGVyZWZvcmUgd2lsbCBnaXZlIGZhbHNlIHBvc2l0aXZlcyBpZiB0ZXN0ZWQgbGlrZSBhIHN0YW5kYXJkIG9iamVjdC5cbiAgICAgICAgaWYgKHRhZyA9PT0gVVJMX1RBRykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZVVybHNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYW4gZXJyb3IgdGFnLCBpdCBzaG91bGQgYmUgdGVzdGVkIGV4cGxpY2l0bHkuIExpa2UgUmVnRXhwLCB0aGUgcHJvcGVydGllcyBhcmUgbm90XG4gICAgICAgIC8vIGVudW1lcmFibGUsIGFuZCB0aGVyZWZvcmUgd2lsbCBnaXZlIGZhbHNlIHBvc2l0aXZlcyBpZiB0ZXN0ZWQgbGlrZSBhIHN0YW5kYXJkIG9iamVjdC5cbiAgICAgICAgaWYgKHRhZyA9PT0gRVJST1JfVEFHKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlRXJyb3JzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGFuIGFyZ3VtZW50cyB0YWcsIGl0IHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgc3RhbmRhcmQgb2JqZWN0LlxuICAgICAgICBpZiAodGFnID09PSBBUkdVTUVOVFNfVEFHKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlT2JqZWN0c0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcyB0aGUgcGVudWx0aW1hdGUgZmFsbGJhY2ssIGNoZWNrIGlmIHRoZSB2YWx1ZXMgcGFzc2VkIGFyZSBwcmltaXRpdmUgd3JhcHBlcnMuIFRoaXNcbiAgICAgICAgLy8gaXMgdmVyeSByYXJlIGluIG1vZGVybiBKUywgd2hpY2ggaXMgd2h5IGl0IGlzIGRlcHJpb3JpdGl6ZWQgY29tcGFyZWQgdG8gYWxsIG90aGVyIG9iamVjdFxuICAgICAgICAvLyB0eXBlcy5cbiAgICAgICAgaWYgKHRhZyA9PT0gQk9PTEVBTl9UQUcgfHwgdGFnID09PSBOVU1CRVJfVEFHIHx8IHRhZyA9PT0gU1RSSU5HX1RBRykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZVByaW1pdGl2ZVdyYXBwZXJzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmtub3duVGFnQ29tcGFyYXRvcnMpIHtcbiAgICAgICAgICAgIHZhciB1bmtub3duVGFnQ29tcGFyYXRvciA9IHVua25vd25UYWdDb21wYXJhdG9yc1t0YWddO1xuICAgICAgICAgICAgaWYgKCF1bmtub3duVGFnQ29tcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIHZhciBzaG9ydFRhZyA9IGdldFNob3J0VGFnKGEpO1xuICAgICAgICAgICAgICAgIGlmIChzaG9ydFRhZykge1xuICAgICAgICAgICAgICAgICAgICB1bmtub3duVGFnQ29tcGFyYXRvciA9IHVua25vd25UYWdDb21wYXJhdG9yc1tzaG9ydFRhZ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGN1c3RvbSBjb25maWcgaGFzIGFuIHVua25vd24gdGFnIGNvbXBhcmF0b3IgdGhhdCBtYXRjaGVzIHRoZSBjYXB0dXJlZCB0YWcgb3IgdGhlXG4gICAgICAgICAgICAvLyBAQHRvU3RyaW5nVGFnLCBpdCBpcyB0aGUgc291cmNlIG9mIHRydXRoIGZvciB3aGV0aGVyIHRoZSB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgICAgICAgaWYgKHVua25vd25UYWdDb21wYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVua25vd25UYWdDb21wYXJhdG9yKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBub3QgbWF0Y2hpbmcgYW55IHRhZ3MgdGhhdCByZXF1aXJlIGEgc3BlY2lmaWMgdHlwZSBvZiBjb21wYXJpc29uLCB0aGVuIHdlIGhhcmQtY29kZSBmYWxzZSBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSBvbmx5IHRoaW5nIHJlbWFpbmluZyBpcyBzdHJpY3QgZXF1YWxpdHksIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gY29tcGFyZWQuIFRoaXMgaXMgZm9yIGEgZmV3IHJlYXNvbnM6XG4gICAgICAgIC8vICAgLSBDZXJ0YWluIHR5cGVzIHRoYXQgY2Fubm90IGJlIGludHJvc3BlY3RlZCAoZS5nLiwgYFdlYWtNYXBgKS4gRm9yIHRoZXNlIHR5cGVzLCB0aGlzIGlzIHRoZSBvbmx5XG4gICAgICAgIC8vICAgICBjb21wYXJpc29uIHRoYXQgY2FuIGJlIG1hZGUuXG4gICAgICAgIC8vICAgLSBGb3IgdHlwZXMgdGhhdCBjYW4gYmUgaW50cm9zcGVjdGVkLCBidXQgcmFyZWx5IGhhdmUgcmVxdWlyZW1lbnRzIHRvIGJlIGNvbXBhcmVkXG4gICAgICAgIC8vICAgICAoYEFycmF5QnVmZmVyYCwgYERhdGFWaWV3YCwgZXRjLiksIHRoZSBjb3N0IGlzIGF2b2lkZWQgdG8gcHJpb3JpdGl6ZSB0aGUgY29tbW9uXG4gICAgICAgIC8vICAgICB1c2UtY2FzZXMgKG1heSBiZSBpbmNsdWRlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLCBpZiByZXF1ZXN0ZWQgZW5vdWdoKS5cbiAgICAgICAgLy8gICAtIEZvciB0eXBlcyB0aGF0IGNhbiBiZSBpbnRyb3NwZWN0ZWQgYnV0IGRvIG5vdCBoYXZlIGFuIG9iamVjdGl2ZSBkZWZpbml0aW9uIG9mIHdoYXRcbiAgICAgICAgLy8gICAgIGVxdWFsaXR5IGlzIChgRXJyb3JgLCBldGMuKSwgdGhlIHN1YmplY3RpdmUgZGVjaXNpb24gaXMgdG8gYmUgY29uc2VydmF0aXZlIGFuZCBzdHJpY3RseSBjb21wYXJlLlxuICAgICAgICAvLyBJbiBhbGwgY2FzZXMsIHRoZXNlIGRlY2lzaW9ucyBzaG91bGQgYmUgcmVldmFsdWF0ZWQgYmFzZWQgb24gY2hhbmdlcyB0byB0aGUgbGFuZ3VhZ2UgYW5kXG4gICAgICAgIC8vIGNvbW1vbiBkZXZlbG9wbWVudCBwcmFjdGljZXMuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHVzZWQgZm9yIGJ1aWxkaW5nIGNvbXBhcmF0b3JzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFcXVhbGl0eUNvbXBhcmF0b3JDb25maWcoX2EpIHtcbiAgICB2YXIgY2lyY3VsYXIgPSBfYS5jaXJjdWxhciwgY3JlYXRlQ3VzdG9tQ29uZmlnID0gX2EuY3JlYXRlQ3VzdG9tQ29uZmlnLCBzdHJpY3QgPSBfYS5zdHJpY3Q7XG4gICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgYXJlQXJyYXlzRXF1YWw6IHN0cmljdFxuICAgICAgICAgICAgPyBhcmVPYmplY3RzRXF1YWxTdHJpY3RcbiAgICAgICAgICAgIDogYXJlQXJyYXlzRXF1YWwsXG4gICAgICAgIGFyZURhdGVzRXF1YWw6IGFyZURhdGVzRXF1YWwsXG4gICAgICAgIGFyZUVycm9yc0VxdWFsOiBhcmVFcnJvcnNFcXVhbCxcbiAgICAgICAgYXJlRnVuY3Rpb25zRXF1YWw6IGFyZUZ1bmN0aW9uc0VxdWFsLFxuICAgICAgICBhcmVNYXBzRXF1YWw6IHN0cmljdFxuICAgICAgICAgICAgPyBjb21iaW5lQ29tcGFyYXRvcnMoYXJlTWFwc0VxdWFsLCBhcmVPYmplY3RzRXF1YWxTdHJpY3QpXG4gICAgICAgICAgICA6IGFyZU1hcHNFcXVhbCxcbiAgICAgICAgYXJlTnVtYmVyc0VxdWFsOiBhcmVOdW1iZXJzRXF1YWwsXG4gICAgICAgIGFyZU9iamVjdHNFcXVhbDogc3RyaWN0XG4gICAgICAgICAgICA/IGFyZU9iamVjdHNFcXVhbFN0cmljdFxuICAgICAgICAgICAgOiBhcmVPYmplY3RzRXF1YWwsXG4gICAgICAgIGFyZVByaW1pdGl2ZVdyYXBwZXJzRXF1YWw6IGFyZVByaW1pdGl2ZVdyYXBwZXJzRXF1YWwsXG4gICAgICAgIGFyZVJlZ0V4cHNFcXVhbDogYXJlUmVnRXhwc0VxdWFsLFxuICAgICAgICBhcmVTZXRzRXF1YWw6IHN0cmljdFxuICAgICAgICAgICAgPyBjb21iaW5lQ29tcGFyYXRvcnMoYXJlU2V0c0VxdWFsLCBhcmVPYmplY3RzRXF1YWxTdHJpY3QpXG4gICAgICAgICAgICA6IGFyZVNldHNFcXVhbCxcbiAgICAgICAgYXJlVHlwZWRBcnJheXNFcXVhbDogc3RyaWN0XG4gICAgICAgICAgICA/IGFyZU9iamVjdHNFcXVhbFN0cmljdFxuICAgICAgICAgICAgOiBhcmVUeXBlZEFycmF5c0VxdWFsLFxuICAgICAgICBhcmVVcmxzRXF1YWw6IGFyZVVybHNFcXVhbCxcbiAgICAgICAgdW5rbm93blRhZ0NvbXBhcmF0b3JzOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgICBpZiAoY3JlYXRlQ3VzdG9tQ29uZmlnKSB7XG4gICAgICAgIGNvbmZpZyA9IGFzc2lnbih7fSwgY29uZmlnLCBjcmVhdGVDdXN0b21Db25maWcoY29uZmlnKSk7XG4gICAgfVxuICAgIGlmIChjaXJjdWxhcikge1xuICAgICAgICB2YXIgYXJlQXJyYXlzRXF1YWwkMSA9IGNyZWF0ZUlzQ2lyY3VsYXIoY29uZmlnLmFyZUFycmF5c0VxdWFsKTtcbiAgICAgICAgdmFyIGFyZU1hcHNFcXVhbCQxID0gY3JlYXRlSXNDaXJjdWxhcihjb25maWcuYXJlTWFwc0VxdWFsKTtcbiAgICAgICAgdmFyIGFyZU9iamVjdHNFcXVhbCQxID0gY3JlYXRlSXNDaXJjdWxhcihjb25maWcuYXJlT2JqZWN0c0VxdWFsKTtcbiAgICAgICAgdmFyIGFyZVNldHNFcXVhbCQxID0gY3JlYXRlSXNDaXJjdWxhcihjb25maWcuYXJlU2V0c0VxdWFsKTtcbiAgICAgICAgY29uZmlnID0gYXNzaWduKHt9LCBjb25maWcsIHtcbiAgICAgICAgICAgIGFyZUFycmF5c0VxdWFsOiBhcmVBcnJheXNFcXVhbCQxLFxuICAgICAgICAgICAgYXJlTWFwc0VxdWFsOiBhcmVNYXBzRXF1YWwkMSxcbiAgICAgICAgICAgIGFyZU9iamVjdHNFcXVhbDogYXJlT2JqZWN0c0VxdWFsJDEsXG4gICAgICAgICAgICBhcmVTZXRzRXF1YWw6IGFyZVNldHNFcXVhbCQxLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZztcbn1cbi8qKlxuICogRGVmYXVsdCBlcXVhbGl0eSBjb21wYXJhdG9yIHBhc3MtdGhyb3VnaCwgdXNlZCBhcyB0aGUgc3RhbmRhcmQgYGlzRXF1YWxgIGNyZWF0b3IgZm9yXG4gKiB1c2UgaW5zaWRlIHRoZSBidWlsdCBjb21wYXJhdG9yLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnRlcm5hbEVxdWFsaXR5Q29tcGFyYXRvcihjb21wYXJlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBfaW5kZXhPcktleUEsIF9pbmRleE9yS2V5QiwgX3BhcmVudEEsIF9wYXJlbnRCLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gY29tcGFyZShhLCBiLCBzdGF0ZSk7XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIHRoZSBgaXNFcXVhbGAgZnVuY3Rpb24gdXNlZCBieSB0aGUgY29uc3VtaW5nIGFwcGxpY2F0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJc0VxdWFsKF9hKSB7XG4gICAgdmFyIGNpcmN1bGFyID0gX2EuY2lyY3VsYXIsIGNvbXBhcmF0b3IgPSBfYS5jb21wYXJhdG9yLCBjcmVhdGVTdGF0ZSA9IF9hLmNyZWF0ZVN0YXRlLCBlcXVhbHMgPSBfYS5lcXVhbHMsIHN0cmljdCA9IF9hLnN0cmljdDtcbiAgICBpZiAoY3JlYXRlU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzRXF1YWwoYSwgYikge1xuICAgICAgICAgICAgdmFyIF9hID0gY3JlYXRlU3RhdGUoKSwgX2IgPSBfYS5jYWNoZSwgY2FjaGUgPSBfYiA9PT0gdm9pZCAwID8gY2lyY3VsYXIgPyBuZXcgV2Vha01hcCgpIDogdW5kZWZpbmVkIDogX2IsIG1ldGEgPSBfYS5tZXRhO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3IoYSwgYiwge1xuICAgICAgICAgICAgICAgIGNhY2hlOiBjYWNoZSxcbiAgICAgICAgICAgICAgICBlcXVhbHM6IGVxdWFscyxcbiAgICAgICAgICAgICAgICBtZXRhOiBtZXRhLFxuICAgICAgICAgICAgICAgIHN0cmljdDogc3RyaWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChjaXJjdWxhcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyYXRvcihhLCBiLCB7XG4gICAgICAgICAgICAgICAgY2FjaGU6IG5ldyBXZWFrTWFwKCksXG4gICAgICAgICAgICAgICAgZXF1YWxzOiBlcXVhbHMsXG4gICAgICAgICAgICAgICAgbWV0YTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHN0cmljdDogc3RyaWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgY2FjaGU6IHVuZGVmaW5lZCxcbiAgICAgICAgZXF1YWxzOiBlcXVhbHMsXG4gICAgICAgIG1ldGE6IHVuZGVmaW5lZCxcbiAgICAgICAgc3RyaWN0OiBzdHJpY3QsXG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJhdG9yKGEsIGIsIHN0YXRlKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGl0ZW1zIHBhc3NlZCBhcmUgZGVlcGx5LWVxdWFsIGluIHZhbHVlLlxuICovXG52YXIgZGVlcEVxdWFsID0gY3JlYXRlQ3VzdG9tRXF1YWwoKTtcbi8qKlxuICogV2hldGhlciB0aGUgaXRlbXMgcGFzc2VkIGFyZSBkZWVwbHktZXF1YWwgaW4gdmFsdWUgYmFzZWQgb24gc3RyaWN0IGNvbXBhcmlzb24uXG4gKi9cbnZhciBzdHJpY3REZWVwRXF1YWwgPSBjcmVhdGVDdXN0b21FcXVhbCh7IHN0cmljdDogdHJ1ZSB9KTtcbi8qKlxuICogV2hldGhlciB0aGUgaXRlbXMgcGFzc2VkIGFyZSBkZWVwbHktZXF1YWwgaW4gdmFsdWUsIGluY2x1ZGluZyBjaXJjdWxhciByZWZlcmVuY2VzLlxuICovXG52YXIgY2lyY3VsYXJEZWVwRXF1YWwgPSBjcmVhdGVDdXN0b21FcXVhbCh7IGNpcmN1bGFyOiB0cnVlIH0pO1xuLyoqXG4gKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIGRlZXBseS1lcXVhbCBpbiB2YWx1ZSwgaW5jbHVkaW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMsXG4gKiBiYXNlZCBvbiBzdHJpY3QgY29tcGFyaXNvbi5cbiAqL1xudmFyIHN0cmljdENpcmN1bGFyRGVlcEVxdWFsID0gY3JlYXRlQ3VzdG9tRXF1YWwoe1xuICAgIGNpcmN1bGFyOiB0cnVlLFxuICAgIHN0cmljdDogdHJ1ZSxcbn0pO1xuLyoqXG4gKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIHNoYWxsb3dseS1lcXVhbCBpbiB2YWx1ZS5cbiAqL1xudmFyIHNoYWxsb3dFcXVhbCA9IGNyZWF0ZUN1c3RvbUVxdWFsKHtcbiAgICBjcmVhdGVJbnRlcm5hbENvbXBhcmF0b3I6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNhbWVWYWx1ZVplcm9FcXVhbDsgfSxcbn0pO1xuLyoqXG4gKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIHNoYWxsb3dseS1lcXVhbCBpbiB2YWx1ZSBiYXNlZCBvbiBzdHJpY3QgY29tcGFyaXNvblxuICovXG52YXIgc3RyaWN0U2hhbGxvd0VxdWFsID0gY3JlYXRlQ3VzdG9tRXF1YWwoe1xuICAgIHN0cmljdDogdHJ1ZSxcbiAgICBjcmVhdGVJbnRlcm5hbENvbXBhcmF0b3I6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNhbWVWYWx1ZVplcm9FcXVhbDsgfSxcbn0pO1xuLyoqXG4gKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIHNoYWxsb3dseS1lcXVhbCBpbiB2YWx1ZSwgaW5jbHVkaW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMuXG4gKi9cbnZhciBjaXJjdWxhclNoYWxsb3dFcXVhbCA9IGNyZWF0ZUN1c3RvbUVxdWFsKHtcbiAgICBjaXJjdWxhcjogdHJ1ZSxcbiAgICBjcmVhdGVJbnRlcm5hbENvbXBhcmF0b3I6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNhbWVWYWx1ZVplcm9FcXVhbDsgfSxcbn0pO1xuLyoqXG4gKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIHNoYWxsb3dseS1lcXVhbCBpbiB2YWx1ZSwgaW5jbHVkaW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMsXG4gKiBiYXNlZCBvbiBzdHJpY3QgY29tcGFyaXNvbi5cbiAqL1xudmFyIHN0cmljdENpcmN1bGFyU2hhbGxvd0VxdWFsID0gY3JlYXRlQ3VzdG9tRXF1YWwoe1xuICAgIGNpcmN1bGFyOiB0cnVlLFxuICAgIGNyZWF0ZUludGVybmFsQ29tcGFyYXRvcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2FtZVZhbHVlWmVyb0VxdWFsOyB9LFxuICAgIHN0cmljdDogdHJ1ZSxcbn0pO1xuLyoqXG4gKiBDcmVhdGUgYSBjdXN0b20gZXF1YWxpdHkgY29tcGFyaXNvbiBtZXRob2QuXG4gKlxuICogVGhpcyBjYW4gYmUgZG9uZSB0byBjcmVhdGUgdmVyeSB0YXJnZXRlZCBjb21wYXJpc29ucyBpbiBleHRyZW1lIGhvdC1wYXRoIHNjZW5hcmlvc1xuICogd2hlcmUgdGhlIHN0YW5kYXJkIG1ldGhvZHMgYXJlIG5vdCBwZXJmb3JtYW50IGVub3VnaCwgYnV0IGNhbiBhbHNvIGJlIHVzZWQgdG8gcHJvdmlkZVxuICogc3VwcG9ydCBmb3IgbGVnYWN5IGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IGV4cGVjdGVkIGZlYXR1cmVzIGxpa2VcbiAqIGBSZWdFeHAucHJvdG90eXBlLmZsYWdzYCBvdXQgb2YgdGhlIGJveC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ3VzdG9tRXF1YWwob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIF9hID0gb3B0aW9ucy5jaXJjdWxhciwgY2lyY3VsYXIgPSBfYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYSwgY3JlYXRlQ3VzdG9tSW50ZXJuYWxDb21wYXJhdG9yID0gb3B0aW9ucy5jcmVhdGVJbnRlcm5hbENvbXBhcmF0b3IsIGNyZWF0ZVN0YXRlID0gb3B0aW9ucy5jcmVhdGVTdGF0ZSwgX2IgPSBvcHRpb25zLnN0cmljdCwgc3RyaWN0ID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2I7XG4gICAgdmFyIGNvbmZpZyA9IGNyZWF0ZUVxdWFsaXR5Q29tcGFyYXRvckNvbmZpZyhvcHRpb25zKTtcbiAgICB2YXIgY29tcGFyYXRvciA9IGNyZWF0ZUVxdWFsaXR5Q29tcGFyYXRvcihjb25maWcpO1xuICAgIHZhciBlcXVhbHMgPSBjcmVhdGVDdXN0b21JbnRlcm5hbENvbXBhcmF0b3JcbiAgICAgICAgPyBjcmVhdGVDdXN0b21JbnRlcm5hbENvbXBhcmF0b3IoY29tcGFyYXRvcilcbiAgICAgICAgOiBjcmVhdGVJbnRlcm5hbEVxdWFsaXR5Q29tcGFyYXRvcihjb21wYXJhdG9yKTtcbiAgICByZXR1cm4gY3JlYXRlSXNFcXVhbCh7IGNpcmN1bGFyOiBjaXJjdWxhciwgY29tcGFyYXRvcjogY29tcGFyYXRvciwgY3JlYXRlU3RhdGU6IGNyZWF0ZVN0YXRlLCBlcXVhbHM6IGVxdWFscywgc3RyaWN0OiBzdHJpY3QgfSk7XG59XG5cbmV4cG9ydCB7IGNpcmN1bGFyRGVlcEVxdWFsLCBjaXJjdWxhclNoYWxsb3dFcXVhbCwgY3JlYXRlQ3VzdG9tRXF1YWwsIGRlZXBFcXVhbCwgc2FtZVZhbHVlWmVyb0VxdWFsLCBzaGFsbG93RXF1YWwsIHN0cmljdENpcmN1bGFyRGVlcEVxdWFsLCBzdHJpY3RDaXJjdWxhclNoYWxsb3dFcXVhbCwgc3RyaWN0RGVlcEVxdWFsLCBzdHJpY3RTaGFsbG93RXF1YWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiaGFzT3duUHJvcGVydHkiLCJwcm90b3R5cGUiLCJjb21iaW5lQ29tcGFyYXRvcnMiLCJjb21wYXJhdG9yQSIsImNvbXBhcmF0b3JCIiwiaXNFcXVhbCIsImEiLCJiIiwic3RhdGUiLCJjcmVhdGVJc0NpcmN1bGFyIiwiYXJlSXRlbXNFcXVhbCIsImlzQ2lyY3VsYXIiLCJjYWNoZSIsImNhY2hlZEEiLCJnZXQiLCJjYWNoZWRCIiwic2V0IiwicmVzdWx0IiwiZGVsZXRlIiwiZ2V0U2hvcnRUYWciLCJ2YWx1ZSIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidW5kZWZpbmVkIiwiZ2V0U3RyaWN0UHJvcGVydGllcyIsIm9iamVjdCIsImNvbmNhdCIsImhhc093biIsInByb3BlcnR5IiwiY2FsbCIsInNhbWVWYWx1ZVplcm9FcXVhbCIsIlBSRUFDVF9WTk9ERSIsIlBSRUFDVF9PV05FUiIsIlJFQUNUX09XTkVSIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwia2V5cyIsImFyZUFycmF5c0VxdWFsIiwiaW5kZXgiLCJsZW5ndGgiLCJlcXVhbHMiLCJhcmVEYXRlc0VxdWFsIiwiZ2V0VGltZSIsImFyZUVycm9yc0VxdWFsIiwibmFtZSIsIm1lc3NhZ2UiLCJjYXVzZSIsInN0YWNrIiwiYXJlRnVuY3Rpb25zRXF1YWwiLCJhcmVNYXBzRXF1YWwiLCJzaXplIiwibWF0Y2hlZEluZGljZXMiLCJBcnJheSIsImFJdGVyYWJsZSIsImVudHJpZXMiLCJhUmVzdWx0IiwiYlJlc3VsdCIsIm5leHQiLCJkb25lIiwiYkl0ZXJhYmxlIiwiaGFzTWF0Y2giLCJtYXRjaEluZGV4IiwiYUVudHJ5IiwiYkVudHJ5IiwiYXJlTnVtYmVyc0VxdWFsIiwiYXJlT2JqZWN0c0VxdWFsIiwicHJvcGVydGllcyIsImlzUHJvcGVydHlFcXVhbCIsImFyZU9iamVjdHNFcXVhbFN0cmljdCIsImRlc2NyaXB0b3JBIiwiZGVzY3JpcHRvckIiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJhcmVQcmltaXRpdmVXcmFwcGVyc0VxdWFsIiwidmFsdWVPZiIsImFyZVJlZ0V4cHNFcXVhbCIsInNvdXJjZSIsImZsYWdzIiwiYXJlU2V0c0VxdWFsIiwidmFsdWVzIiwiYXJlVHlwZWRBcnJheXNFcXVhbCIsImFyZVVybHNFcXVhbCIsImhvc3RuYW1lIiwicGF0aG5hbWUiLCJwcm90b2NvbCIsInBvcnQiLCJoYXNoIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsIiQkdHlwZW9mIiwiQVJHVU1FTlRTX1RBRyIsIkJPT0xFQU5fVEFHIiwiREFURV9UQUciLCJFUlJPUl9UQUciLCJNQVBfVEFHIiwiTlVNQkVSX1RBRyIsIk9CSkVDVF9UQUciLCJSRUdfRVhQX1RBRyIsIlNFVF9UQUciLCJTVFJJTkdfVEFHIiwiVVJMX1RBRyIsImlzQXJyYXkiLCJpc1R5cGVkQXJyYXkiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImFzc2lnbiIsImdldFRhZyIsInRvU3RyaW5nIiwiYmluZCIsImNyZWF0ZUVxdWFsaXR5Q29tcGFyYXRvciIsIl9hIiwidW5rbm93blRhZ0NvbXBhcmF0b3JzIiwiY29tcGFyYXRvciIsInR5cGUiLCJjb25zdHJ1Y3RvciIsIkRhdGUiLCJSZWdFeHAiLCJNYXAiLCJTZXQiLCJ0YWciLCJ0aGVuIiwidW5rbm93blRhZ0NvbXBhcmF0b3IiLCJzaG9ydFRhZyIsImNyZWF0ZUVxdWFsaXR5Q29tcGFyYXRvckNvbmZpZyIsImNpcmN1bGFyIiwiY3JlYXRlQ3VzdG9tQ29uZmlnIiwic3RyaWN0IiwiY29uZmlnIiwiYXJlQXJyYXlzRXF1YWwkMSIsImFyZU1hcHNFcXVhbCQxIiwiYXJlT2JqZWN0c0VxdWFsJDEiLCJhcmVTZXRzRXF1YWwkMSIsImNyZWF0ZUludGVybmFsRXF1YWxpdHlDb21wYXJhdG9yIiwiY29tcGFyZSIsIl9pbmRleE9yS2V5QSIsIl9pbmRleE9yS2V5QiIsIl9wYXJlbnRBIiwiX3BhcmVudEIiLCJjcmVhdGVJc0VxdWFsIiwiY3JlYXRlU3RhdGUiLCJfYiIsIldlYWtNYXAiLCJtZXRhIiwiZGVlcEVxdWFsIiwiY3JlYXRlQ3VzdG9tRXF1YWwiLCJzdHJpY3REZWVwRXF1YWwiLCJjaXJjdWxhckRlZXBFcXVhbCIsInN0cmljdENpcmN1bGFyRGVlcEVxdWFsIiwic2hhbGxvd0VxdWFsIiwiY3JlYXRlSW50ZXJuYWxDb21wYXJhdG9yIiwic3RyaWN0U2hhbGxvd0VxdWFsIiwiY2lyY3VsYXJTaGFsbG93RXF1YWwiLCJzdHJpY3RDaXJjdWxhclNoYWxsb3dFcXVhbCIsIm9wdGlvbnMiLCJjcmVhdGVDdXN0b21JbnRlcm5hbENvbXBhcmF0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-equals/dist/esm/index.mjs\n");

/***/ })

};
;