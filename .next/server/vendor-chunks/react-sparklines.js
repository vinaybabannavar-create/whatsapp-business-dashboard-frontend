"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-sparklines";
exports.ids = ["vendor-chunks/react-sparklines"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-sparklines/build/index.js":
/*!******************************************************!*\
  !*** ./node_modules/react-sparklines/build/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n(function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n    else {}\n})(void 0, function(__WEBPACK_EXTERNAL_MODULE_1__) {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_682__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_682__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_682__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_682__.c = installedModules;\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_682__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_682__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    /******/ configurable: false,\n                    /******/ enumerable: true,\n                    /******/ get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_682__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_682__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_682__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_682__.p = \"/\";\n        /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_682__(__nested_webpack_require_682__.s = 11);\n    /******/ }([\n        /* 0 */ /***/ function(module1, exports1, __nested_webpack_require_3371__) {\n            /* WEBPACK VAR INJECTION */ (function(process) {\n                if (true) {\n                    var REACT_ELEMENT_TYPE = typeof Symbol === \"function\" && Symbol.for && Symbol.for(\"react.element\") || 0xeac7;\n                    var isValidElement = function(object) {\n                        return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n                    };\n                    // By explicitly using `prop-types` you are opting into new development behavior.\n                    // http://fb.me/prop-types-in-prod\n                    var throwOnDirectAccess = true;\n                    module1.exports = __nested_webpack_require_3371__(14)(isValidElement, throwOnDirectAccess);\n                } else {}\n            /* WEBPACK VAR INJECTION */ }).call(exports1, __nested_webpack_require_3371__(2));\n        /***/ },\n        /* 1 */ /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n        /***/ },\n        /* 2 */ /***/ function(module1, exports1) {\n            // shim for using process in browser\n            var process = module1.exports = {};\n            // cached from whatever global is present so that test runners that stub it\n            // don't break things.  But we need to wrap it in a try catch in case it is\n            // wrapped in strict mode code which doesn't define any globals.  It's inside a\n            // function because try/catches deoptimize in certain engines.\n            var cachedSetTimeout;\n            var cachedClearTimeout;\n            function defaultSetTimout() {\n                throw new Error(\"setTimeout has not been defined\");\n            }\n            function defaultClearTimeout() {\n                throw new Error(\"clearTimeout has not been defined\");\n            }\n            (function() {\n                try {\n                    if (typeof setTimeout === \"function\") {\n                        cachedSetTimeout = setTimeout;\n                    } else {\n                        cachedSetTimeout = defaultSetTimout;\n                    }\n                } catch (e) {\n                    cachedSetTimeout = defaultSetTimout;\n                }\n                try {\n                    if (typeof clearTimeout === \"function\") {\n                        cachedClearTimeout = clearTimeout;\n                    } else {\n                        cachedClearTimeout = defaultClearTimeout;\n                    }\n                } catch (e) {\n                    cachedClearTimeout = defaultClearTimeout;\n                }\n            })();\n            function runTimeout(fun) {\n                if (cachedSetTimeout === setTimeout) {\n                    //normal enviroments in sane situations\n                    return setTimeout(fun, 0);\n                }\n                // if setTimeout wasn't available but was latter defined\n                if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n                    cachedSetTimeout = setTimeout;\n                    return setTimeout(fun, 0);\n                }\n                try {\n                    // when when somebody has screwed with setTimeout but no I.E. maddness\n                    return cachedSetTimeout(fun, 0);\n                } catch (e) {\n                    try {\n                        // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n                        return cachedSetTimeout.call(null, fun, 0);\n                    } catch (e) {\n                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n                        return cachedSetTimeout.call(this, fun, 0);\n                    }\n                }\n            }\n            function runClearTimeout(marker) {\n                if (cachedClearTimeout === clearTimeout) {\n                    //normal enviroments in sane situations\n                    return clearTimeout(marker);\n                }\n                // if clearTimeout wasn't available but was latter defined\n                if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n                    cachedClearTimeout = clearTimeout;\n                    return clearTimeout(marker);\n                }\n                try {\n                    // when when somebody has screwed with setTimeout but no I.E. maddness\n                    return cachedClearTimeout(marker);\n                } catch (e) {\n                    try {\n                        // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n                        return cachedClearTimeout.call(null, marker);\n                    } catch (e) {\n                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n                        // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n                        return cachedClearTimeout.call(this, marker);\n                    }\n                }\n            }\n            var queue = [];\n            var draining = false;\n            var currentQueue;\n            var queueIndex = -1;\n            function cleanUpNextTick() {\n                if (!draining || !currentQueue) {\n                    return;\n                }\n                draining = false;\n                if (currentQueue.length) {\n                    queue = currentQueue.concat(queue);\n                } else {\n                    queueIndex = -1;\n                }\n                if (queue.length) {\n                    drainQueue();\n                }\n            }\n            function drainQueue() {\n                if (draining) {\n                    return;\n                }\n                var timeout = runTimeout(cleanUpNextTick);\n                draining = true;\n                var len = queue.length;\n                while(len){\n                    currentQueue = queue;\n                    queue = [];\n                    while(++queueIndex < len){\n                        if (currentQueue) {\n                            currentQueue[queueIndex].run();\n                        }\n                    }\n                    queueIndex = -1;\n                    len = queue.length;\n                }\n                currentQueue = null;\n                draining = false;\n                runClearTimeout(timeout);\n            }\n            process.nextTick = function(fun) {\n                var args = new Array(arguments.length - 1);\n                if (arguments.length > 1) {\n                    for(var i = 1; i < arguments.length; i++){\n                        args[i - 1] = arguments[i];\n                    }\n                }\n                queue.push(new Item(fun, args));\n                if (queue.length === 1 && !draining) {\n                    runTimeout(drainQueue);\n                }\n            };\n            // v8 likes predictible objects\n            function Item(fun, array) {\n                this.fun = fun;\n                this.array = array;\n            }\n            Item.prototype.run = function() {\n                this.fun.apply(null, this.array);\n            };\n            process.title = \"browser\";\n            process.browser = true;\n            process.env = {};\n            process.argv = [];\n            process.version = \"\"; // empty string to avoid regexp issues\n            process.versions = {};\n            function noop() {}\n            process.on = noop;\n            process.addListener = noop;\n            process.once = noop;\n            process.off = noop;\n            process.removeListener = noop;\n            process.removeAllListeners = noop;\n            process.emit = noop;\n            process.prependListener = noop;\n            process.prependOnceListener = noop;\n            process.listeners = function(name) {\n                return [];\n            };\n            process.binding = function(name) {\n                throw new Error(\"process.binding is not supported\");\n            };\n            process.cwd = function() {\n                return \"/\";\n            };\n            process.chdir = function(dir) {\n                throw new Error(\"process.chdir is not supported\");\n            };\n            process.umask = function() {\n                return 0;\n            };\n        /***/ },\n        /* 3 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = function(data) {\n                return data.reduce(function(a, b) {\n                    return a + b;\n                }) / data.length;\n            };\n        /***/ },\n        /* 4 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            /**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */ function makeEmptyFunction(arg) {\n                return function() {\n                    return arg;\n                };\n            }\n            /**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */ var emptyFunction = function emptyFunction() {};\n            emptyFunction.thatReturns = makeEmptyFunction;\n            emptyFunction.thatReturnsFalse = makeEmptyFunction(false);\n            emptyFunction.thatReturnsTrue = makeEmptyFunction(true);\n            emptyFunction.thatReturnsNull = makeEmptyFunction(null);\n            emptyFunction.thatReturnsThis = function() {\n                return this;\n            };\n            emptyFunction.thatReturnsArgument = function(arg) {\n                return arg;\n            };\n            module1.exports = emptyFunction;\n        /***/ },\n        /* 5 */ /***/ function(module1, exports1, __nested_webpack_require_14037__) {\n            \"use strict\";\n            /* WEBPACK VAR INJECTION */ (function(process) {\n                /**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */ var validateFormat = function validateFormat(format) {};\n                if (true) {\n                    validateFormat = function validateFormat(format) {\n                        if (format === undefined) {\n                            throw new Error(\"invariant requires an error message argument\");\n                        }\n                    };\n                }\n                function invariant(condition, format, a, b, c, d, e, f) {\n                    validateFormat(format);\n                    if (!condition) {\n                        var error;\n                        if (format === undefined) {\n                            error = new Error(\"Minified exception occurred; use the non-minified dev environment \" + \"for the full error message and additional helpful warnings.\");\n                        } else {\n                            var args = [\n                                a,\n                                b,\n                                c,\n                                d,\n                                e,\n                                f\n                            ];\n                            var argIndex = 0;\n                            error = new Error(format.replace(/%s/g, function() {\n                                return args[argIndex++];\n                            }));\n                            error.name = \"Invariant Violation\";\n                        }\n                        error.framesToPop = 1; // we don't care about invariant's own frame\n                        throw error;\n                    }\n                }\n                module1.exports = invariant;\n            /* WEBPACK VAR INJECTION */ }).call(exports1, __nested_webpack_require_14037__(2));\n        /***/ },\n        /* 6 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            /**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */ var ReactPropTypesSecret = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\n            module1.exports = ReactPropTypesSecret;\n        /***/ },\n        /* 7 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = function(data) {\n                return Math.min.apply(Math, data);\n            };\n        /***/ },\n        /* 8 */ /***/ function(module1, exports1, __nested_webpack_require_17229__) {\n            \"use strict\";\n            /* WEBPACK VAR INJECTION */ (function(process) {\n                var emptyFunction = __nested_webpack_require_17229__(4);\n                /**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */ var warning = emptyFunction;\n                if (true) {\n                    var printWarning = function printWarning(format) {\n                        for(var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                            args[_key - 1] = arguments[_key];\n                        }\n                        var argIndex = 0;\n                        var message = \"Warning: \" + format.replace(/%s/g, function() {\n                            return args[argIndex++];\n                        });\n                        if (typeof console !== \"undefined\") {\n                            console.error(message);\n                        }\n                        try {\n                            // --- Welcome to debugging React ---\n                            // This error was thrown as a convenience so that you can use this stack\n                            // to find the callsite that caused this warning to fire.\n                            throw new Error(message);\n                        } catch (x) {}\n                    };\n                    warning = function warning(condition, format) {\n                        if (format === undefined) {\n                            throw new Error(\"`warning(condition, format, ...args)` requires a warning \" + \"message argument\");\n                        }\n                        if (format.indexOf(\"Failed Composite propType: \") === 0) {\n                            return; // Ignore CompositeComponent proptype check.\n                        }\n                        if (!condition) {\n                            for(var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++){\n                                args[_key2 - 2] = arguments[_key2];\n                            }\n                            printWarning.apply(undefined, [\n                                format\n                            ].concat(args));\n                        }\n                    };\n                }\n                module1.exports = warning;\n            /* WEBPACK VAR INJECTION */ }).call(exports1, __nested_webpack_require_17229__(2));\n        /***/ },\n        /* 9 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = function(data) {\n                return Math.max.apply(Math, data);\n            };\n        /***/ },\n        /* 10 */ /***/ function(module1, exports1, __nested_webpack_require_20298__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _mean = __nested_webpack_require_20298__(3);\n            var _mean2 = _interopRequireDefault(_mean);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            exports1.default = function(data) {\n                var dataMean = (0, _mean2.default)(data);\n                var sqDiff = data.map(function(n) {\n                    return Math.pow(n - dataMean, 2);\n                });\n                var avgSqDiff = (0, _mean2.default)(sqDiff);\n                return Math.sqrt(avgSqDiff);\n            };\n        /***/ },\n        /* 11 */ /***/ function(module1, exports1, __nested_webpack_require_21148__) {\n            module1.exports = __nested_webpack_require_21148__(12);\n        /***/ },\n        /* 12 */ /***/ function(module1, exports1, __nested_webpack_require_21294__) {\n            \"use strict\";\n            module1.exports = __nested_webpack_require_21294__(13);\n        /***/ },\n        /* 13 */ /***/ function(module1, exports1, __nested_webpack_require_21466__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.SparklinesText = exports1.SparklinesNormalBand = exports1.SparklinesReferenceLine = exports1.SparklinesSpots = exports1.SparklinesBars = exports1.SparklinesCurve = exports1.SparklinesLine = exports1.Sparklines = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _propTypes = __nested_webpack_require_21466__(0);\n            var _propTypes2 = _interopRequireDefault(_propTypes);\n            var _react = __nested_webpack_require_21466__(1);\n            var _react2 = _interopRequireDefault(_react);\n            var _SparklinesText = __nested_webpack_require_21466__(17);\n            var _SparklinesText2 = _interopRequireDefault(_SparklinesText);\n            var _SparklinesLine = __nested_webpack_require_21466__(18);\n            var _SparklinesLine2 = _interopRequireDefault(_SparklinesLine);\n            var _SparklinesCurve = __nested_webpack_require_21466__(19);\n            var _SparklinesCurve2 = _interopRequireDefault(_SparklinesCurve);\n            var _SparklinesBars = __nested_webpack_require_21466__(20);\n            var _SparklinesBars2 = _interopRequireDefault(_SparklinesBars);\n            var _SparklinesSpots = __nested_webpack_require_21466__(21);\n            var _SparklinesSpots2 = _interopRequireDefault(_SparklinesSpots);\n            var _SparklinesReferenceLine = __nested_webpack_require_21466__(22);\n            var _SparklinesReferenceLine2 = _interopRequireDefault(_SparklinesReferenceLine);\n            var _SparklinesNormalBand = __nested_webpack_require_21466__(27);\n            var _SparklinesNormalBand2 = _interopRequireDefault(_SparklinesNormalBand);\n            var _dataToPoints = __nested_webpack_require_21466__(28);\n            var _dataToPoints2 = _interopRequireDefault(_dataToPoints);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self, call) {\n                if (!self) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Sparklines = function(_PureComponent) {\n                _inherits(Sparklines, _PureComponent);\n                function Sparklines(props) {\n                    _classCallCheck(this, Sparklines);\n                    return _possibleConstructorReturn(this, (Sparklines.__proto__ || Object.getPrototypeOf(Sparklines)).call(this, props));\n                }\n                _createClass(Sparklines, [\n                    {\n                        key: \"render\",\n                        value: function render() {\n                            var _props = this.props, data = _props.data, limit = _props.limit, width = _props.width, height = _props.height, svgWidth = _props.svgWidth, svgHeight = _props.svgHeight, preserveAspectRatio = _props.preserveAspectRatio, margin = _props.margin, style = _props.style, max = _props.max, min = _props.min;\n                            if (data.length === 0) return null;\n                            var points = (0, _dataToPoints2.default)({\n                                data: data,\n                                limit: limit,\n                                width: width,\n                                height: height,\n                                margin: margin,\n                                max: max,\n                                min: min\n                            });\n                            var svgOpts = {\n                                style: style,\n                                viewBox: \"0 0 \" + width + \" \" + height,\n                                preserveAspectRatio: preserveAspectRatio\n                            };\n                            if (svgWidth > 0) svgOpts.width = svgWidth;\n                            if (svgHeight > 0) svgOpts.height = svgHeight;\n                            return _react2.default.createElement(\"svg\", svgOpts, _react2.default.Children.map(this.props.children, function(child) {\n                                return _react2.default.cloneElement(child, {\n                                    data: data,\n                                    points: points,\n                                    width: width,\n                                    height: height,\n                                    margin: margin\n                                });\n                            }));\n                        }\n                    }\n                ]);\n                return Sparklines;\n            }(_react.PureComponent);\n            Sparklines.propTypes = {\n                data: _propTypes2.default.array,\n                limit: _propTypes2.default.number,\n                width: _propTypes2.default.number,\n                height: _propTypes2.default.number,\n                svgWidth: _propTypes2.default.number,\n                svgHeight: _propTypes2.default.number,\n                preserveAspectRatio: _propTypes2.default.string,\n                margin: _propTypes2.default.number,\n                style: _propTypes2.default.object,\n                min: _propTypes2.default.number,\n                max: _propTypes2.default.number,\n                onMouseMove: _propTypes2.default.func\n            };\n            Sparklines.defaultProps = {\n                data: [],\n                width: 240,\n                height: 60,\n                //Scale the graphic content of the given element non-uniformly if necessary such that the element's bounding box exactly matches the viewport rectangle.\n                preserveAspectRatio: \"none\",\n                margin: 2\n            };\n            exports1.Sparklines = Sparklines;\n            exports1.SparklinesLine = _SparklinesLine2.default;\n            exports1.SparklinesCurve = _SparklinesCurve2.default;\n            exports1.SparklinesBars = _SparklinesBars2.default;\n            exports1.SparklinesSpots = _SparklinesSpots2.default;\n            exports1.SparklinesReferenceLine = _SparklinesReferenceLine2.default;\n            exports1.SparklinesNormalBand = _SparklinesNormalBand2.default;\n            exports1.SparklinesText = _SparklinesText2.default;\n        /***/ },\n        /* 14 */ /***/ function(module1, exports1, __nested_webpack_require_29668__) {\n            \"use strict\";\n            /* WEBPACK VAR INJECTION */ (function(process) {\n                var emptyFunction = __nested_webpack_require_29668__(4);\n                var invariant = __nested_webpack_require_29668__(5);\n                var warning = __nested_webpack_require_29668__(8);\n                var ReactPropTypesSecret = __nested_webpack_require_29668__(6);\n                var checkPropTypes = __nested_webpack_require_29668__(15);\n                module1.exports = function(isValidElement, throwOnDirectAccess) {\n                    /* global Symbol */ var ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\n                    var FAUX_ITERATOR_SYMBOL = \"@@iterator\"; // Before Symbol spec.\n                    /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */ function getIteratorFn(maybeIterable) {\n                        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n                        if (typeof iteratorFn === \"function\") {\n                            return iteratorFn;\n                        }\n                    }\n                    /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */ var ANONYMOUS = \"<<anonymous>>\";\n                    // Important!\n                    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n                    var ReactPropTypes = {\n                        array: createPrimitiveTypeChecker(\"array\"),\n                        bool: createPrimitiveTypeChecker(\"boolean\"),\n                        func: createPrimitiveTypeChecker(\"function\"),\n                        number: createPrimitiveTypeChecker(\"number\"),\n                        object: createPrimitiveTypeChecker(\"object\"),\n                        string: createPrimitiveTypeChecker(\"string\"),\n                        symbol: createPrimitiveTypeChecker(\"symbol\"),\n                        any: createAnyTypeChecker(),\n                        arrayOf: createArrayOfTypeChecker,\n                        element: createElementTypeChecker(),\n                        instanceOf: createInstanceTypeChecker,\n                        node: createNodeChecker(),\n                        objectOf: createObjectOfTypeChecker,\n                        oneOf: createEnumTypeChecker,\n                        oneOfType: createUnionTypeChecker,\n                        shape: createShapeTypeChecker\n                    };\n                    /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */ /*eslint-disable no-self-compare*/ function is(x, y) {\n                        // SameValue algorithm\n                        if (x === y) {\n                            // Steps 1-5, 7-10\n                            // Steps 6.b-6.e: +0 != -0\n                            return x !== 0 || 1 / x === 1 / y;\n                        } else {\n                            // Step 6.a: NaN == NaN\n                            return x !== x && y !== y;\n                        }\n                    }\n                    /*eslint-enable no-self-compare*/ /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */ function PropTypeError(message) {\n                        this.message = message;\n                        this.stack = \"\";\n                    }\n                    // Make `instanceof Error` still work for returned errors.\n                    PropTypeError.prototype = Error.prototype;\n                    function createChainableTypeChecker(validate) {\n                        if (true) {\n                            var manualPropTypeCallCache = {};\n                            var manualPropTypeWarningCount = 0;\n                        }\n                        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n                            componentName = componentName || ANONYMOUS;\n                            propFullName = propFullName || propName;\n                            if (secret !== ReactPropTypesSecret) {\n                                if (throwOnDirectAccess) {\n                                    // New behavior only for users of `prop-types` package\n                                    invariant(false, \"Calling PropTypes validators directly is not supported by the `prop-types` package. \" + \"Use `PropTypes.checkPropTypes()` to call them. \" + \"Read more at http://fb.me/use-check-prop-types\");\n                                } else if ( true && typeof console !== \"undefined\") {\n                                    // Old behavior for people using React.PropTypes\n                                    var cacheKey = componentName + \":\" + propName;\n                                    if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors\n                                    manualPropTypeWarningCount < 3) {\n                                        warning(false, \"You are manually calling a React.PropTypes validation \" + \"function for the `%s` prop on `%s`. This is deprecated \" + \"and will throw in the standalone `prop-types` package. \" + \"You may be seeing this warning due to a third-party PropTypes \" + \"library. See https://fb.me/react-warning-dont-call-proptypes \" + \"for details.\", propFullName, componentName);\n                                        manualPropTypeCallCache[cacheKey] = true;\n                                        manualPropTypeWarningCount++;\n                                    }\n                                }\n                            }\n                            if (props[propName] == null) {\n                                if (isRequired) {\n                                    if (props[propName] === null) {\n                                        return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required \" + (\"in `\" + componentName + \"`, but its value is `null`.\"));\n                                    }\n                                    return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required in \" + (\"`\" + componentName + \"`, but its value is `undefined`.\"));\n                                }\n                                return null;\n                            } else {\n                                return validate(props, propName, componentName, location, propFullName);\n                            }\n                        }\n                        var chainedCheckType = checkType.bind(null, false);\n                        chainedCheckType.isRequired = checkType.bind(null, true);\n                        return chainedCheckType;\n                    }\n                    function createPrimitiveTypeChecker(expectedType) {\n                        function validate(props, propName, componentName, location, propFullName, secret) {\n                            var propValue = props[propName];\n                            var propType = getPropType(propValue);\n                            if (propType !== expectedType) {\n                                // `propValue` being instance of, say, date/regexp, pass the 'object'\n                                // check, but we can offer a more precise error message here rather than\n                                // 'of type `object`'.\n                                var preciseType = getPreciseType(propValue);\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + preciseType + \"` supplied to `\" + componentName + \"`, expected \") + (\"`\" + expectedType + \"`.\"));\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createAnyTypeChecker() {\n                        return createChainableTypeChecker(emptyFunction.thatReturnsNull);\n                    }\n                    function createArrayOfTypeChecker(typeChecker) {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            if (typeof typeChecker !== \"function\") {\n                                return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside arrayOf.\");\n                            }\n                            var propValue = props[propName];\n                            if (!Array.isArray(propValue)) {\n                                var propType = getPropType(propValue);\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an array.\"));\n                            }\n                            for(var i = 0; i < propValue.length; i++){\n                                var error = typeChecker(propValue, i, componentName, location, propFullName + \"[\" + i + \"]\", ReactPropTypesSecret);\n                                if (error instanceof Error) {\n                                    return error;\n                                }\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createElementTypeChecker() {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            var propValue = props[propName];\n                            if (!isValidElement(propValue)) {\n                                var propType = getPropType(propValue);\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected a single ReactElement.\"));\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createInstanceTypeChecker(expectedClass) {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            if (!(props[propName] instanceof expectedClass)) {\n                                var expectedClassName = expectedClass.name || ANONYMOUS;\n                                var actualClassName = getClassName(props[propName]);\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + actualClassName + \"` supplied to `\" + componentName + \"`, expected \") + (\"instance of `\" + expectedClassName + \"`.\"));\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createEnumTypeChecker(expectedValues) {\n                        if (!Array.isArray(expectedValues)) {\n                             true ? warning(false, \"Invalid argument supplied to oneOf, expected an instance of array.\") : 0;\n                            return emptyFunction.thatReturnsNull;\n                        }\n                        function validate(props, propName, componentName, location, propFullName) {\n                            var propValue = props[propName];\n                            for(var i = 0; i < expectedValues.length; i++){\n                                if (is(propValue, expectedValues[i])) {\n                                    return null;\n                                }\n                            }\n                            var valuesString = JSON.stringify(expectedValues);\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of value `\" + propValue + \"` \" + (\"supplied to `\" + componentName + \"`, expected one of \" + valuesString + \".\"));\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createObjectOfTypeChecker(typeChecker) {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            if (typeof typeChecker !== \"function\") {\n                                return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside objectOf.\");\n                            }\n                            var propValue = props[propName];\n                            var propType = getPropType(propValue);\n                            if (propType !== \"object\") {\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an object.\"));\n                            }\n                            for(var key in propValue){\n                                if (propValue.hasOwnProperty(key)) {\n                                    var error = typeChecker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                                    if (error instanceof Error) {\n                                        return error;\n                                    }\n                                }\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createUnionTypeChecker(arrayOfTypeCheckers) {\n                        if (!Array.isArray(arrayOfTypeCheckers)) {\n                             true ? warning(false, \"Invalid argument supplied to oneOfType, expected an instance of array.\") : 0;\n                            return emptyFunction.thatReturnsNull;\n                        }\n                        for(var i = 0; i < arrayOfTypeCheckers.length; i++){\n                            var checker = arrayOfTypeCheckers[i];\n                            if (typeof checker !== \"function\") {\n                                warning(false, \"Invalid argument supplid to oneOfType. Expected an array of check functions, but \" + \"received %s at index %s.\", getPostfixForTypeWarning(checker), i);\n                                return emptyFunction.thatReturnsNull;\n                            }\n                        }\n                        function validate(props, propName, componentName, location, propFullName) {\n                            for(var i = 0; i < arrayOfTypeCheckers.length; i++){\n                                var checker = arrayOfTypeCheckers[i];\n                                if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\n                                    return null;\n                                }\n                            }\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`.\"));\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createNodeChecker() {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            if (!isNode(props[propName])) {\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`, expected a ReactNode.\"));\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createShapeTypeChecker(shapeTypes) {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            var propValue = props[propName];\n                            var propType = getPropType(propValue);\n                            if (propType !== \"object\") {\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n                            }\n                            for(var key in shapeTypes){\n                                var checker = shapeTypes[key];\n                                if (!checker) {\n                                    continue;\n                                }\n                                var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                                if (error) {\n                                    return error;\n                                }\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function isNode(propValue) {\n                        switch(typeof propValue){\n                            case \"number\":\n                            case \"string\":\n                            case \"undefined\":\n                                return true;\n                            case \"boolean\":\n                                return !propValue;\n                            case \"object\":\n                                if (Array.isArray(propValue)) {\n                                    return propValue.every(isNode);\n                                }\n                                if (propValue === null || isValidElement(propValue)) {\n                                    return true;\n                                }\n                                var iteratorFn = getIteratorFn(propValue);\n                                if (iteratorFn) {\n                                    var iterator = iteratorFn.call(propValue);\n                                    var step;\n                                    if (iteratorFn !== propValue.entries) {\n                                        while(!(step = iterator.next()).done){\n                                            if (!isNode(step.value)) {\n                                                return false;\n                                            }\n                                        }\n                                    } else {\n                                        // Iterator will provide entry [k,v] tuples rather than values.\n                                        while(!(step = iterator.next()).done){\n                                            var entry = step.value;\n                                            if (entry) {\n                                                if (!isNode(entry[1])) {\n                                                    return false;\n                                                }\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    return false;\n                                }\n                                return true;\n                            default:\n                                return false;\n                        }\n                    }\n                    function isSymbol(propType, propValue) {\n                        // Native Symbol.\n                        if (propType === \"symbol\") {\n                            return true;\n                        }\n                        // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n                        if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n                            return true;\n                        }\n                        // Fallback for non-spec compliant Symbols which are polyfilled.\n                        if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n                            return true;\n                        }\n                        return false;\n                    }\n                    // Equivalent of `typeof` but with special handling for array and regexp.\n                    function getPropType(propValue) {\n                        var propType = typeof propValue;\n                        if (Array.isArray(propValue)) {\n                            return \"array\";\n                        }\n                        if (propValue instanceof RegExp) {\n                            // Old webkits (at least until Android 4.0) return 'function' rather than\n                            // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n                            // passes PropTypes.object.\n                            return \"object\";\n                        }\n                        if (isSymbol(propType, propValue)) {\n                            return \"symbol\";\n                        }\n                        return propType;\n                    }\n                    // This handles more types than `getPropType`. Only used for error messages.\n                    // See `createPrimitiveTypeChecker`.\n                    function getPreciseType(propValue) {\n                        if (typeof propValue === \"undefined\" || propValue === null) {\n                            return \"\" + propValue;\n                        }\n                        var propType = getPropType(propValue);\n                        if (propType === \"object\") {\n                            if (propValue instanceof Date) {\n                                return \"date\";\n                            } else if (propValue instanceof RegExp) {\n                                return \"regexp\";\n                            }\n                        }\n                        return propType;\n                    }\n                    // Returns a string that is postfixed to a warning about an invalid type.\n                    // For example, \"undefined\" or \"of type array\"\n                    function getPostfixForTypeWarning(value) {\n                        var type = getPreciseType(value);\n                        switch(type){\n                            case \"array\":\n                            case \"object\":\n                                return \"an \" + type;\n                            case \"boolean\":\n                            case \"date\":\n                            case \"regexp\":\n                                return \"a \" + type;\n                            default:\n                                return type;\n                        }\n                    }\n                    // Returns class name of the object, if any.\n                    function getClassName(propValue) {\n                        if (!propValue.constructor || !propValue.constructor.name) {\n                            return ANONYMOUS;\n                        }\n                        return propValue.constructor.name;\n                    }\n                    ReactPropTypes.checkPropTypes = checkPropTypes;\n                    ReactPropTypes.PropTypes = ReactPropTypes;\n                    return ReactPropTypes;\n                };\n            /* WEBPACK VAR INJECTION */ }).call(exports1, __nested_webpack_require_29668__(2));\n        /***/ },\n        /* 15 */ /***/ function(module1, exports1, __nested_webpack_require_55637__) {\n            \"use strict\";\n            /* WEBPACK VAR INJECTION */ (function(process) {\n                if (true) {\n                    var invariant = __nested_webpack_require_55637__(5);\n                    var warning = __nested_webpack_require_55637__(8);\n                    var ReactPropTypesSecret = __nested_webpack_require_55637__(6);\n                    var loggedTypeFailures = {};\n                }\n                /**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */ function checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n                    if (true) {\n                        for(var typeSpecName in typeSpecs){\n                            if (typeSpecs.hasOwnProperty(typeSpecName)) {\n                                var error;\n                                // Prop type validation may throw. In case they do, we don't want to\n                                // fail the render phase where it didn't fail before. So we log it.\n                                // After these have been cleaned up, we'll let them throw.\n                                try {\n                                    // This is intentionally an invariant that gets caught. It's the same\n                                    // behavior as without this statement except with a better message.\n                                    invariant(typeof typeSpecs[typeSpecName] === \"function\", \"%s: %s type `%s` is invalid; it must be a function, usually from \" + \"React.PropTypes.\", componentName || \"React class\", location, typeSpecName);\n                                    error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n                                } catch (ex) {\n                                    error = ex;\n                                }\n                                warning(!error || error instanceof Error, \"%s: type specification of %s `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error);\n                                if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n                                    // Only monitor this failure once because there tends to be a lot of the\n                                    // same error.\n                                    loggedTypeFailures[error.message] = true;\n                                    var stack = getStack ? getStack() : \"\";\n                                    warning(false, \"Failed %s type: %s%s\", location, error.message, stack != null ? stack : \"\");\n                                }\n                            }\n                        }\n                    }\n                }\n                module1.exports = checkPropTypes;\n            /* WEBPACK VAR INJECTION */ }).call(exports1, __nested_webpack_require_55637__(2));\n        /***/ },\n        /* 16 */ /***/ function(module1, exports1, __nested_webpack_require_59238__) {\n            \"use strict\";\n            /**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */ var emptyFunction = __nested_webpack_require_59238__(4);\n            var invariant = __nested_webpack_require_59238__(5);\n            var ReactPropTypesSecret = __nested_webpack_require_59238__(6);\n            module1.exports = function() {\n                function shim(props, propName, componentName, location, propFullName, secret) {\n                    if (secret === ReactPropTypesSecret) {\n                        // It is still safe when called from React.\n                        return;\n                    }\n                    invariant(false, \"Calling PropTypes validators directly is not supported by the `prop-types` package. \" + \"Use PropTypes.checkPropTypes() to call them. \" + \"Read more at http://fb.me/use-check-prop-types\");\n                }\n                ;\n                shim.isRequired = shim;\n                function getShim() {\n                    return shim;\n                }\n                ;\n                // Important!\n                // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n                var ReactPropTypes = {\n                    array: shim,\n                    bool: shim,\n                    func: shim,\n                    number: shim,\n                    object: shim,\n                    string: shim,\n                    symbol: shim,\n                    any: shim,\n                    arrayOf: getShim,\n                    element: shim,\n                    instanceOf: getShim,\n                    node: shim,\n                    objectOf: getShim,\n                    oneOf: getShim,\n                    oneOfType: getShim,\n                    shape: getShim\n                };\n                ReactPropTypes.checkPropTypes = emptyFunction;\n                ReactPropTypes.PropTypes = ReactPropTypes;\n                return ReactPropTypes;\n            };\n        /***/ },\n        /* 17 */ /***/ function(module1, exports1, __nested_webpack_require_61485__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _propTypes = __nested_webpack_require_61485__(0);\n            var _propTypes2 = _interopRequireDefault(_propTypes);\n            var _react = __nested_webpack_require_61485__(1);\n            var _react2 = _interopRequireDefault(_react);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self, call) {\n                if (!self) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var SparklinesText = function(_React$Component) {\n                _inherits(SparklinesText, _React$Component);\n                function SparklinesText() {\n                    _classCallCheck(this, SparklinesText);\n                    return _possibleConstructorReturn(this, (SparklinesText.__proto__ || Object.getPrototypeOf(SparklinesText)).apply(this, arguments));\n                }\n                _createClass(SparklinesText, [\n                    {\n                        key: \"render\",\n                        value: function render() {\n                            var _props = this.props, point = _props.point, text = _props.text, fontSize = _props.fontSize, fontFamily = _props.fontFamily;\n                            var x = point.x, y = point.y;\n                            return _react2.default.createElement(\"g\", null, _react2.default.createElement(\"text\", {\n                                x: x,\n                                y: y,\n                                fontFamily: fontFamily || \"Verdana\",\n                                fontSize: fontSize || 10\n                            }, text));\n                        }\n                    }\n                ]);\n                return SparklinesText;\n            }(_react2.default.Component);\n            SparklinesText.propTypes = {\n                text: _propTypes2.default.string,\n                point: _propTypes2.default.object,\n                fontSize: _propTypes2.default.number,\n                fontFamily: _propTypes2.default.string\n            };\n            SparklinesText.defaultProps = {\n                text: \"\",\n                point: {\n                    x: 0,\n                    y: 0\n                }\n            };\n            exports1.default = SparklinesText;\n        /***/ },\n        /* 18 */ /***/ function(module1, exports1, __nested_webpack_require_66058__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _propTypes = __nested_webpack_require_66058__(0);\n            var _propTypes2 = _interopRequireDefault(_propTypes);\n            var _react = __nested_webpack_require_66058__(1);\n            var _react2 = _interopRequireDefault(_react);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self, call) {\n                if (!self) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var SparklinesLine = function(_React$Component) {\n                _inherits(SparklinesLine, _React$Component);\n                function SparklinesLine() {\n                    _classCallCheck(this, SparklinesLine);\n                    return _possibleConstructorReturn(this, (SparklinesLine.__proto__ || Object.getPrototypeOf(SparklinesLine)).apply(this, arguments));\n                }\n                _createClass(SparklinesLine, [\n                    {\n                        key: \"render\",\n                        value: function render() {\n                            var _props = this.props, data = _props.data, points = _props.points, width = _props.width, height = _props.height, margin = _props.margin, color = _props.color, style = _props.style, onMouseMove = _props.onMouseMove;\n                            var linePoints = points.map(function(p) {\n                                return [\n                                    p.x,\n                                    p.y\n                                ];\n                            }).reduce(function(a, b) {\n                                return a.concat(b);\n                            });\n                            var closePolyPoints = [\n                                points[points.length - 1].x,\n                                height - margin,\n                                margin,\n                                height - margin,\n                                margin,\n                                points[0].y\n                            ];\n                            var fillPoints = linePoints.concat(closePolyPoints);\n                            var lineStyle = {\n                                stroke: color || style.stroke || \"slategray\",\n                                strokeWidth: style.strokeWidth || \"1\",\n                                strokeLinejoin: style.strokeLinejoin || \"round\",\n                                strokeLinecap: style.strokeLinecap || \"round\",\n                                fill: \"none\"\n                            };\n                            var fillStyle = {\n                                stroke: style.stroke || \"none\",\n                                strokeWidth: \"0\",\n                                fillOpacity: style.fillOpacity || \".1\",\n                                fill: style.fill || color || \"slategray\",\n                                pointerEvents: \"auto\"\n                            };\n                            var tooltips = points.map(function(p, i) {\n                                return _react2.default.createElement(\"circle\", {\n                                    key: i,\n                                    cx: p.x,\n                                    cy: p.y,\n                                    r: 2,\n                                    style: fillStyle,\n                                    onMouseEnter: function onMouseEnter(e) {\n                                        return onMouseMove(\"enter\", data[i], p);\n                                    },\n                                    onClick: function onClick(e) {\n                                        return onMouseMove(\"click\", data[i], p);\n                                    }\n                                });\n                            });\n                            return _react2.default.createElement(\"g\", null, tooltips, _react2.default.createElement(\"polyline\", {\n                                points: fillPoints.join(\" \"),\n                                style: fillStyle\n                            }), _react2.default.createElement(\"polyline\", {\n                                points: linePoints.join(\" \"),\n                                style: lineStyle\n                            }));\n                        }\n                    }\n                ]);\n                return SparklinesLine;\n            }(_react2.default.Component);\n            SparklinesLine.propTypes = {\n                color: _propTypes2.default.string,\n                style: _propTypes2.default.object\n            };\n            SparklinesLine.defaultProps = {\n                style: {},\n                onMouseMove: function onMouseMove() {}\n            };\n            exports1.default = SparklinesLine;\n        /***/ },\n        /* 19 */ /***/ function(module1, exports1, __nested_webpack_require_73088__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _propTypes = __nested_webpack_require_73088__(0);\n            var _propTypes2 = _interopRequireDefault(_propTypes);\n            var _react = __nested_webpack_require_73088__(1);\n            var _react2 = _interopRequireDefault(_react);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self, call) {\n                if (!self) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var SparklinesCurve = function(_React$Component) {\n                _inherits(SparklinesCurve, _React$Component);\n                function SparklinesCurve() {\n                    _classCallCheck(this, SparklinesCurve);\n                    return _possibleConstructorReturn(this, (SparklinesCurve.__proto__ || Object.getPrototypeOf(SparklinesCurve)).apply(this, arguments));\n                }\n                _createClass(SparklinesCurve, [\n                    {\n                        key: \"render\",\n                        value: function render() {\n                            var _props = this.props, points = _props.points, width = _props.width, height = _props.height, margin = _props.margin, color = _props.color, style = _props.style, _props$divisor = _props.divisor, divisor = _props$divisor === undefined ? 0.25 : _props$divisor;\n                            var prev = void 0;\n                            var curve = function curve(p) {\n                                var res = void 0;\n                                if (!prev) {\n                                    res = [\n                                        p.x,\n                                        p.y\n                                    ];\n                                } else {\n                                    var len = (p.x - prev.x) * divisor;\n                                    res = [\n                                        \"C\",\n                                        //x1\n                                        prev.x + len,\n                                        //y1\n                                        prev.y,\n                                        //x2,\n                                        p.x - len,\n                                        //y2,\n                                        p.y,\n                                        //x,\n                                        p.x,\n                                        //y\n                                        p.y\n                                    ];\n                                }\n                                prev = p;\n                                return res;\n                            };\n                            var linePoints = points.map(function(p) {\n                                return curve(p);\n                            }).reduce(function(a, b) {\n                                return a.concat(b);\n                            });\n                            var closePolyPoints = [\n                                \"L\" + points[points.length - 1].x,\n                                height - margin,\n                                margin,\n                                height - margin,\n                                margin,\n                                points[0].y\n                            ];\n                            var fillPoints = linePoints.concat(closePolyPoints);\n                            var lineStyle = {\n                                stroke: color || style.stroke || \"slategray\",\n                                strokeWidth: style.strokeWidth || \"1\",\n                                strokeLinejoin: style.strokeLinejoin || \"round\",\n                                strokeLinecap: style.strokeLinecap || \"round\",\n                                fill: \"none\"\n                            };\n                            var fillStyle = {\n                                stroke: style.stroke || \"none\",\n                                strokeWidth: \"0\",\n                                fillOpacity: style.fillOpacity || \".1\",\n                                fill: style.fill || color || \"slategray\"\n                            };\n                            return _react2.default.createElement(\"g\", null, _react2.default.createElement(\"path\", {\n                                d: \"M\" + fillPoints.join(\" \"),\n                                style: fillStyle\n                            }), _react2.default.createElement(\"path\", {\n                                d: \"M\" + linePoints.join(\" \"),\n                                style: lineStyle\n                            }));\n                        }\n                    }\n                ]);\n                return SparklinesCurve;\n            }(_react2.default.Component);\n            SparklinesCurve.propTypes = {\n                color: _propTypes2.default.string,\n                style: _propTypes2.default.object\n            };\n            SparklinesCurve.defaultProps = {\n                style: {}\n            };\n            exports1.default = SparklinesCurve;\n        /***/ },\n        /* 20 */ /***/ function(module1, exports1, __nested_webpack_require_80434__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _propTypes = __nested_webpack_require_80434__(0);\n            var _propTypes2 = _interopRequireDefault(_propTypes);\n            var _react = __nested_webpack_require_80434__(1);\n            var _react2 = _interopRequireDefault(_react);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self, call) {\n                if (!self) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var SparklinesBars = function(_React$Component) {\n                _inherits(SparklinesBars, _React$Component);\n                function SparklinesBars() {\n                    _classCallCheck(this, SparklinesBars);\n                    return _possibleConstructorReturn(this, (SparklinesBars.__proto__ || Object.getPrototypeOf(SparklinesBars)).apply(this, arguments));\n                }\n                _createClass(SparklinesBars, [\n                    {\n                        key: \"render\",\n                        value: function render() {\n                            var _this2 = this;\n                            var _props = this.props, points = _props.points, height = _props.height, style = _props.style, barWidth = _props.barWidth, margin = _props.margin, onMouseMove = _props.onMouseMove;\n                            var strokeWidth = 1 * (style && style.strokeWidth || 0);\n                            var marginWidth = margin ? 2 * margin : 0;\n                            var width = barWidth || (points && points.length >= 2 ? Math.max(0, points[1].x - points[0].x - strokeWidth - marginWidth) : 0);\n                            return _react2.default.createElement(\"g\", {\n                                transform: \"scale(1,-1)\"\n                            }, points.map(function(p, i) {\n                                return _react2.default.createElement(\"rect\", {\n                                    key: i,\n                                    x: p.x - (width + strokeWidth) / 2,\n                                    y: -height,\n                                    width: width,\n                                    height: Math.max(0, height - p.y),\n                                    style: style,\n                                    onMouseMove: onMouseMove && onMouseMove.bind(_this2, p)\n                                });\n                            }));\n                        }\n                    }\n                ]);\n                return SparklinesBars;\n            }(_react2.default.Component);\n            SparklinesBars.propTypes = {\n                points: _propTypes2.default.arrayOf(_propTypes2.default.object),\n                height: _propTypes2.default.number,\n                style: _propTypes2.default.object,\n                barWidth: _propTypes2.default.number,\n                margin: _propTypes2.default.number,\n                onMouseMove: _propTypes2.default.func\n            };\n            SparklinesBars.defaultProps = {\n                style: {\n                    fill: \"slategray\"\n                }\n            };\n            exports1.default = SparklinesBars;\n        /***/ },\n        /* 21 */ /***/ function(module1, exports1, __nested_webpack_require_85864__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _propTypes = __nested_webpack_require_85864__(0);\n            var _propTypes2 = _interopRequireDefault(_propTypes);\n            var _react = __nested_webpack_require_85864__(1);\n            var _react2 = _interopRequireDefault(_react);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self, call) {\n                if (!self) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var SparklinesSpots = function(_React$Component) {\n                _inherits(SparklinesSpots, _React$Component);\n                function SparklinesSpots() {\n                    _classCallCheck(this, SparklinesSpots);\n                    return _possibleConstructorReturn(this, (SparklinesSpots.__proto__ || Object.getPrototypeOf(SparklinesSpots)).apply(this, arguments));\n                }\n                _createClass(SparklinesSpots, [\n                    {\n                        key: \"lastDirection\",\n                        value: function lastDirection(points) {\n                            Math.sign = Math.sign || function(x) {\n                                return x > 0 ? 1 : -1;\n                            };\n                            return points.length < 2 ? 0 : Math.sign(points[points.length - 2].y - points[points.length - 1].y);\n                        }\n                    },\n                    {\n                        key: \"render\",\n                        value: function render() {\n                            var _props = this.props, points = _props.points, width = _props.width, height = _props.height, size = _props.size, style = _props.style, spotColors = _props.spotColors;\n                            var startSpot = _react2.default.createElement(\"circle\", {\n                                cx: points[0].x,\n                                cy: points[0].y,\n                                r: size,\n                                style: style\n                            });\n                            var endSpot = _react2.default.createElement(\"circle\", {\n                                cx: points[points.length - 1].x,\n                                cy: points[points.length - 1].y,\n                                r: size,\n                                style: style || {\n                                    fill: spotColors[this.lastDirection(points)]\n                                }\n                            });\n                            return _react2.default.createElement(\"g\", null, style && startSpot, endSpot);\n                        }\n                    }\n                ]);\n                return SparklinesSpots;\n            }(_react2.default.Component);\n            SparklinesSpots.propTypes = {\n                size: _propTypes2.default.number,\n                style: _propTypes2.default.object,\n                spotColors: _propTypes2.default.object\n            };\n            SparklinesSpots.defaultProps = {\n                size: 2,\n                spotColors: {\n                    \"-1\": \"red\",\n                    \"0\": \"black\",\n                    \"1\": \"green\"\n                }\n            };\n            exports1.default = SparklinesSpots;\n        /***/ },\n        /* 22 */ /***/ function(module1, exports1, __nested_webpack_require_91397__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _propTypes = __nested_webpack_require_91397__(0);\n            var _propTypes2 = _interopRequireDefault(_propTypes);\n            var _react = __nested_webpack_require_91397__(1);\n            var _react2 = _interopRequireDefault(_react);\n            var _dataProcessing = __nested_webpack_require_91397__(23);\n            var dataProcessing = _interopRequireWildcard(_dataProcessing);\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                } else {\n                    var newObj = {};\n                    if (obj != null) {\n                        for(var key in obj){\n                            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n                        }\n                    }\n                    newObj.default = obj;\n                    return newObj;\n                }\n            }\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self, call) {\n                if (!self) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var SparklinesReferenceLine = function(_React$Component) {\n                _inherits(SparklinesReferenceLine, _React$Component);\n                function SparklinesReferenceLine() {\n                    _classCallCheck(this, SparklinesReferenceLine);\n                    return _possibleConstructorReturn(this, (SparklinesReferenceLine.__proto__ || Object.getPrototypeOf(SparklinesReferenceLine)).apply(this, arguments));\n                }\n                _createClass(SparklinesReferenceLine, [\n                    {\n                        key: \"render\",\n                        value: function render() {\n                            var _props = this.props, points = _props.points, margin = _props.margin, type = _props.type, style = _props.style, value = _props.value;\n                            var ypoints = points.map(function(p) {\n                                return p.y;\n                            });\n                            var y = type == \"custom\" ? value : dataProcessing[type](ypoints);\n                            return _react2.default.createElement(\"line\", {\n                                x1: points[0].x,\n                                y1: y + margin,\n                                x2: points[points.length - 1].x,\n                                y2: y + margin,\n                                style: style\n                            });\n                        }\n                    }\n                ]);\n                return SparklinesReferenceLine;\n            }(_react2.default.Component);\n            SparklinesReferenceLine.propTypes = {\n                type: _propTypes2.default.oneOf([\n                    \"max\",\n                    \"min\",\n                    \"mean\",\n                    \"avg\",\n                    \"median\",\n                    \"custom\"\n                ]),\n                value: _propTypes2.default.number,\n                style: _propTypes2.default.object\n            };\n            SparklinesReferenceLine.defaultProps = {\n                type: \"mean\",\n                style: {\n                    stroke: \"red\",\n                    strokeOpacity: .75,\n                    strokeDasharray: \"2, 2\"\n                }\n            };\n            exports1.default = SparklinesReferenceLine;\n        /***/ },\n        /* 23 */ /***/ function(module1, exports1, __nested_webpack_require_97134__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.variance = exports1.stdev = exports1.median = exports1.midRange = exports1.avg = exports1.mean = exports1.max = exports1.min = undefined;\n            var _min2 = __nested_webpack_require_97134__(7);\n            var _min3 = _interopRequireDefault(_min2);\n            var _mean2 = __nested_webpack_require_97134__(3);\n            var _mean3 = _interopRequireDefault(_mean2);\n            var _midRange2 = __nested_webpack_require_97134__(24);\n            var _midRange3 = _interopRequireDefault(_midRange2);\n            var _median2 = __nested_webpack_require_97134__(25);\n            var _median3 = _interopRequireDefault(_median2);\n            var _stdev2 = __nested_webpack_require_97134__(10);\n            var _stdev3 = _interopRequireDefault(_stdev2);\n            var _variance2 = __nested_webpack_require_97134__(26);\n            var _variance3 = _interopRequireDefault(_variance2);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            exports1.min = _min3.default;\n            exports1.max = _min3.default;\n            exports1.mean = _mean3.default;\n            exports1.avg = _mean3.default;\n            exports1.midRange = _midRange3.default;\n            exports1.median = _median3.default;\n            exports1.stdev = _stdev3.default;\n            exports1.variance = _variance3.default;\n        /***/ },\n        /* 24 */ /***/ function(module1, exports1, __nested_webpack_require_98725__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _min = __nested_webpack_require_98725__(7);\n            var _min2 = _interopRequireDefault(_min);\n            var _max = __nested_webpack_require_98725__(9);\n            var _max2 = _interopRequireDefault(_max);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            exports1.default = function(data) {\n                return (0, _max2.default)(data) - (0, _min2.default)(data) / 2;\n            };\n        /***/ },\n        /* 25 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = function(data) {\n                return data.sort(function(a, b) {\n                    return a - b;\n                })[Math.floor(data.length / 2)];\n            };\n        /***/ },\n        /* 26 */ /***/ function(module1, exports1, __nested_webpack_require_99880__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _mean = __nested_webpack_require_99880__(3);\n            var _mean2 = _interopRequireDefault(_mean);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            exports1.default = function(data) {\n                var dataMean = (0, _mean2.default)(data);\n                var sq = data.map(function(n) {\n                    return Math.pow(n - dataMean, 2);\n                });\n                return (0, _mean2.default)(sq);\n            };\n        /***/ },\n        /* 27 */ /***/ function(module1, exports1, __nested_webpack_require_100668__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _propTypes = __nested_webpack_require_100668__(0);\n            var _propTypes2 = _interopRequireDefault(_propTypes);\n            var _react = __nested_webpack_require_100668__(1);\n            var _react2 = _interopRequireDefault(_react);\n            var _mean = __nested_webpack_require_100668__(3);\n            var _mean2 = _interopRequireDefault(_mean);\n            var _stdev = __nested_webpack_require_100668__(10);\n            var _stdev2 = _interopRequireDefault(_stdev);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self, call) {\n                if (!self) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var SparklinesNormalBand = function(_React$Component) {\n                _inherits(SparklinesNormalBand, _React$Component);\n                function SparklinesNormalBand() {\n                    _classCallCheck(this, SparklinesNormalBand);\n                    return _possibleConstructorReturn(this, (SparklinesNormalBand.__proto__ || Object.getPrototypeOf(SparklinesNormalBand)).apply(this, arguments));\n                }\n                _createClass(SparklinesNormalBand, [\n                    {\n                        key: \"render\",\n                        value: function render() {\n                            var _props = this.props, points = _props.points, margin = _props.margin, style = _props.style;\n                            var ypoints = points.map(function(p) {\n                                return p.y;\n                            });\n                            var dataMean = (0, _mean2.default)(ypoints);\n                            var dataStdev = (0, _stdev2.default)(ypoints);\n                            return _react2.default.createElement(\"rect\", {\n                                x: points[0].x,\n                                y: dataMean - dataStdev + margin,\n                                width: points[points.length - 1].x - points[0].x,\n                                height: _stdev2.default * 2,\n                                style: style\n                            });\n                        }\n                    }\n                ]);\n                return SparklinesNormalBand;\n            }(_react2.default.Component);\n            SparklinesNormalBand.propTypes = {\n                style: _propTypes2.default.object\n            };\n            SparklinesNormalBand.defaultProps = {\n                style: {\n                    fill: \"red\",\n                    fillOpacity: .1\n                }\n            };\n            exports1.default = SparklinesNormalBand;\n        /***/ },\n        /* 28 */ /***/ function(module1, exports1, __nested_webpack_require_105604__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _min = __nested_webpack_require_105604__(7);\n            var _min2 = _interopRequireDefault(_min);\n            var _max = __nested_webpack_require_105604__(9);\n            var _max2 = _interopRequireDefault(_max);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            exports1.default = function(_ref) {\n                var data = _ref.data, limit = _ref.limit, _ref$width = _ref.width, width = _ref$width === undefined ? 1 : _ref$width, _ref$height = _ref.height, height = _ref$height === undefined ? 1 : _ref$height, _ref$margin = _ref.margin, margin = _ref$margin === undefined ? 0 : _ref$margin, _ref$max = _ref.max, max = _ref$max === undefined ? (0, _max2.default)(data) : _ref$max, _ref$min = _ref.min, min = _ref$min === undefined ? (0, _min2.default)(data) : _ref$min;\n                var len = data.length;\n                if (limit && limit < len) {\n                    data = data.slice(len - limit);\n                }\n                var vfactor = (height - margin * 2) / (max - min || 2);\n                var hfactor = (width - margin * 2) / ((limit || len) - (len > 1 ? 1 : 0));\n                return data.map(function(d, i) {\n                    return {\n                        x: i * hfactor + margin,\n                        y: (max === min ? 1 : max - d) * vfactor + margin\n                    };\n                });\n            };\n        /***/ }\n    ]);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3BhcmtsaW5lcy9idWlsZC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUMsVUFBU0EsaUNBQWlDQyxJQUFJLEVBQUVDLE9BQU87SUFDdkQsSUFBRyxJQUFpRCxFQUNuREUsT0FBT0QsT0FBTyxHQUFHRCxRQUFRRyxtQkFBT0EsQ0FBQyx3R0FBTztTQUNwQyxFQUs2QztBQUNuRCxHQUFHLFFBQU0sU0FBU0csNkJBQTZCO0lBQy9DLE9BQWdCLE1BQUgsR0FBSSxTQUFTQyxPQUFPO1FBQ2pDLE1BQU0sR0FBSSxtQkFBbUI7UUFDN0IsTUFBTSxHQUFJLElBQUlDLG1CQUFtQixDQUFDO1FBQ2xDLE1BQU0sR0FDTixNQUFNLEdBQUksdUJBQXVCO1FBQ2pDLE1BQU0sR0FBSSxTQUFTQyw4QkFBbUJBLENBQUNDLFFBQVE7WUFDL0MsTUFBTSxHQUNOLE1BQU0sR0FBSyw4QkFBOEI7WUFDekMsTUFBTSxHQUFLLElBQUdGLGdCQUFnQixDQUFDRSxTQUFTLEVBQUU7Z0JBQzFDLE1BQU0sR0FBTSxPQUFPRixnQkFBZ0IsQ0FBQ0UsU0FBUyxDQUFDVCxPQUFPO1lBQ3JELE1BQU0sR0FBSztZQUNYLE1BQU0sR0FBSyxrREFBa0Q7WUFDN0QsTUFBTSxHQUFLLElBQUlDLFVBQVNNLGdCQUFnQixDQUFDRSxTQUFTLEdBQUc7Z0JBQ3JELE1BQU0sR0FBTUMsR0FBR0Q7Z0JBQ2YsTUFBTSxHQUFNRSxHQUFHO2dCQUNmLE1BQU0sR0FBTVgsU0FBUyxDQUFDO1lBQ1g7WUFDWCxNQUFNLEdBQ04sTUFBTSxHQUFLLDhCQUE4QjtZQUN6QyxNQUFNLEdBQUtNLE9BQU8sQ0FBQ0csU0FBUyxDQUFDRyxJQUFJLENBQUNYLFFBQU9ELE9BQU8sRUFBRUMsU0FBUUEsUUFBT0QsT0FBTyxFQUFFUSw4QkFBbUJBO1lBQzdGLE1BQU0sR0FDTixNQUFNLEdBQUssNEJBQTRCO1lBQ3ZDLE1BQU0sR0FBS1AsUUFBT1UsQ0FBQyxHQUFHO1lBQ3RCLE1BQU0sR0FD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SyxTQUFTLEtBQU0sRUFBQ04sU0FBU3hJLEdBQUUsSUFBTUEsQ0FBQUEsTUFBTSxJQUFJLElBQUksRUFBQztnQkFFdkUsT0FBT2tDLEtBQUsyQyxHQUFHLENBQUMsU0FBVTVILENBQUMsRUFBRUwsQ0FBQztvQkFDMUIsT0FBTzt3QkFDSHNILEdBQUd0SCxJQUFJZ1ksVUFBVTlMO3dCQUNqQmdELEdBQUcsQ0FBQ3hILFFBQVFYLE1BQU0sSUFBSVcsTUFBTXJILENBQUFBLElBQUswWCxVQUFVN0w7b0JBQy9DO2dCQUNKO1lBQ0o7UUFFQSxHQUFHLEdBQUc7S0FDSTtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2hhdHNhcHAtYnVzaW5lc3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNwYXJrbGluZXMvYnVpbGQvaW5kZXguanM/OWFlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJyZWFjdFwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJSZWFjdFNwYXJrbGluZXNcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiUmVhY3RTcGFya2xpbmVzXCJdID0gZmFjdG9yeShyb290W1wiUmVhY3RcIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xX18pIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL1wiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDExKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKHByb2Nlc3MpIHsvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICBTeW1ib2wuZm9yICYmXG4gICAgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuICAgIDB4ZWFjNztcblxuICB2YXIgaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG9iamVjdCAhPT0gbnVsbCAmJlxuICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH07XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KSgpO1xufVxuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygyKSkpXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fO1xuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSArIGI7XG4gICAgfSkgLyBkYXRhLmxlbmd0aDtcbn07XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7LyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG5cblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpO1xuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSlcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuXG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkoTWF0aCwgZGF0YSk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24ocHJvY2Vzcykgey8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG5cblxudmFyIGVtcHR5RnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICByZXR1cm47IC8vIElnbm9yZSBDb21wb3NpdGVDb21wb25lbnQgcHJvcHR5cGUgY2hlY2suXG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSlcblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgZGF0YSk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tZWFuID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9tZWFuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lYW4pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBkYXRhTWVhbiA9ICgwLCBfbWVhbjIuZGVmYXVsdCkoZGF0YSk7XG4gICAgdmFyIHNxRGlmZiA9IGRhdGEubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdyhuIC0gZGF0YU1lYW4sIDIpO1xuICAgIH0pO1xuICAgIHZhciBhdmdTcURpZmYgPSAoMCwgX21lYW4yLmRlZmF1bHQpKHNxRGlmZik7XG4gICAgcmV0dXJuIE1hdGguc3FydChhdmdTcURpZmYpO1xufTtcblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlNwYXJrbGluZXNUZXh0ID0gZXhwb3J0cy5TcGFya2xpbmVzTm9ybWFsQmFuZCA9IGV4cG9ydHMuU3BhcmtsaW5lc1JlZmVyZW5jZUxpbmUgPSBleHBvcnRzLlNwYXJrbGluZXNTcG90cyA9IGV4cG9ydHMuU3BhcmtsaW5lc0JhcnMgPSBleHBvcnRzLlNwYXJrbGluZXNDdXJ2ZSA9IGV4cG9ydHMuU3BhcmtsaW5lc0xpbmUgPSBleHBvcnRzLlNwYXJrbGluZXMgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfcHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxudmFyIF9yZWFjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX1NwYXJrbGluZXNUZXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cbnZhciBfU3BhcmtsaW5lc1RleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3BhcmtsaW5lc1RleHQpO1xuXG52YXIgX1NwYXJrbGluZXNMaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cbnZhciBfU3BhcmtsaW5lc0xpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3BhcmtsaW5lc0xpbmUpO1xuXG52YXIgX1NwYXJrbGluZXNDdXJ2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG52YXIgX1NwYXJrbGluZXNDdXJ2ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TcGFya2xpbmVzQ3VydmUpO1xuXG52YXIgX1NwYXJrbGluZXNCYXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbnZhciBfU3BhcmtsaW5lc0JhcnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3BhcmtsaW5lc0JhcnMpO1xuXG52YXIgX1NwYXJrbGluZXNTcG90cyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXG52YXIgX1NwYXJrbGluZXNTcG90czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TcGFya2xpbmVzU3BvdHMpO1xuXG52YXIgX1NwYXJrbGluZXNSZWZlcmVuY2VMaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cbnZhciBfU3BhcmtsaW5lc1JlZmVyZW5jZUxpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3BhcmtsaW5lc1JlZmVyZW5jZUxpbmUpO1xuXG52YXIgX1NwYXJrbGluZXNOb3JtYWxCYW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cbnZhciBfU3BhcmtsaW5lc05vcm1hbEJhbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3BhcmtsaW5lc05vcm1hbEJhbmQpO1xuXG52YXIgX2RhdGFUb1BvaW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXG52YXIgX2RhdGFUb1BvaW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kYXRhVG9Qb2ludHMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBTcGFya2xpbmVzID0gZnVuY3Rpb24gKF9QdXJlQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKFNwYXJrbGluZXMsIF9QdXJlQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIFNwYXJrbGluZXMocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwYXJrbGluZXMpO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3BhcmtsaW5lcy5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNwYXJrbGluZXMpKS5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFNwYXJrbGluZXMsIFt7XG4gICAgICAgIGtleTogJ3JlbmRlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICBkYXRhID0gX3Byb3BzLmRhdGEsXG4gICAgICAgICAgICAgICAgbGltaXQgPSBfcHJvcHMubGltaXQsXG4gICAgICAgICAgICAgICAgd2lkdGggPSBfcHJvcHMud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gX3Byb3BzLmhlaWdodCxcbiAgICAgICAgICAgICAgICBzdmdXaWR0aCA9IF9wcm9wcy5zdmdXaWR0aCxcbiAgICAgICAgICAgICAgICBzdmdIZWlnaHQgPSBfcHJvcHMuc3ZnSGVpZ2h0LFxuICAgICAgICAgICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW8gPSBfcHJvcHMucHJlc2VydmVBc3BlY3RSYXRpbyxcbiAgICAgICAgICAgICAgICBtYXJnaW4gPSBfcHJvcHMubWFyZ2luLFxuICAgICAgICAgICAgICAgIHN0eWxlID0gX3Byb3BzLnN0eWxlLFxuICAgICAgICAgICAgICAgIG1heCA9IF9wcm9wcy5tYXgsXG4gICAgICAgICAgICAgICAgbWluID0gX3Byb3BzLm1pbjtcblxuXG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gKDAsIF9kYXRhVG9Qb2ludHMyLmRlZmF1bHQpKHsgZGF0YTogZGF0YSwgbGltaXQ6IGxpbWl0LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBtYXJnaW46IG1hcmdpbiwgbWF4OiBtYXgsIG1pbjogbWluIH0pO1xuXG4gICAgICAgICAgICB2YXIgc3ZnT3B0cyA9IHsgc3R5bGU6IHN0eWxlLCB2aWV3Qm94OiAnMCAwICcgKyB3aWR0aCArICcgJyArIGhlaWdodCwgcHJlc2VydmVBc3BlY3RSYXRpbzogcHJlc2VydmVBc3BlY3RSYXRpbyB9O1xuICAgICAgICAgICAgaWYgKHN2Z1dpZHRoID4gMCkgc3ZnT3B0cy53aWR0aCA9IHN2Z1dpZHRoO1xuICAgICAgICAgICAgaWYgKHN2Z0hlaWdodCA+IDApIHN2Z09wdHMuaGVpZ2h0ID0gc3ZnSGVpZ2h0O1xuXG4gICAgICAgICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ3N2ZycsXG4gICAgICAgICAgICAgICAgc3ZnT3B0cyxcbiAgICAgICAgICAgICAgICBfcmVhY3QyLmRlZmF1bHQuQ2hpbGRyZW4ubWFwKHRoaXMucHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNsb25lRWxlbWVudChjaGlsZCwgeyBkYXRhOiBkYXRhLCBwb2ludHM6IHBvaW50cywgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgbWFyZ2luOiBtYXJnaW4gfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gU3BhcmtsaW5lcztcbn0oX3JlYWN0LlB1cmVDb21wb25lbnQpO1xuXG5TcGFya2xpbmVzLnByb3BUeXBlcyA9IHtcbiAgICBkYXRhOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmFycmF5LFxuICAgIGxpbWl0OiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm51bWJlcixcbiAgICB3aWR0aDogX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIsXG4gICAgaGVpZ2h0OiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm51bWJlcixcbiAgICBzdmdXaWR0aDogX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIsXG4gICAgc3ZnSGVpZ2h0OiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm51bWJlcixcbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcbiAgICBtYXJnaW46IF9wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyLFxuICAgIHN0eWxlOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdCxcbiAgICBtaW46IF9wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyLFxuICAgIG1heDogX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIsXG4gICAgb25Nb3VzZU1vdmU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuY1xufTtcblNwYXJrbGluZXMuZGVmYXVsdFByb3BzID0ge1xuICAgIGRhdGE6IFtdLFxuICAgIHdpZHRoOiAyNDAsXG4gICAgaGVpZ2h0OiA2MCxcbiAgICAvL1NjYWxlIHRoZSBncmFwaGljIGNvbnRlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnQgbm9uLXVuaWZvcm1seSBpZiBuZWNlc3Nhcnkgc3VjaCB0aGF0IHRoZSBlbGVtZW50J3MgYm91bmRpbmcgYm94IGV4YWN0bHkgbWF0Y2hlcyB0aGUgdmlld3BvcnQgcmVjdGFuZ2xlLlxuICAgIHByZXNlcnZlQXNwZWN0UmF0aW86ICdub25lJywgLy9odHRwczovL3d3dy53My5vcmcvVFIvU1ZHL2Nvb3Jkcy5odG1sI1ByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGVcbiAgICBtYXJnaW46IDJcbn07XG5leHBvcnRzLlNwYXJrbGluZXMgPSBTcGFya2xpbmVzO1xuZXhwb3J0cy5TcGFya2xpbmVzTGluZSA9IF9TcGFya2xpbmVzTGluZTIuZGVmYXVsdDtcbmV4cG9ydHMuU3BhcmtsaW5lc0N1cnZlID0gX1NwYXJrbGluZXNDdXJ2ZTIuZGVmYXVsdDtcbmV4cG9ydHMuU3BhcmtsaW5lc0JhcnMgPSBfU3BhcmtsaW5lc0JhcnMyLmRlZmF1bHQ7XG5leHBvcnRzLlNwYXJrbGluZXNTcG90cyA9IF9TcGFya2xpbmVzU3BvdHMyLmRlZmF1bHQ7XG5leHBvcnRzLlNwYXJrbGluZXNSZWZlcmVuY2VMaW5lID0gX1NwYXJrbGluZXNSZWZlcmVuY2VMaW5lMi5kZWZhdWx0O1xuZXhwb3J0cy5TcGFya2xpbmVzTm9ybWFsQmFuZCA9IF9TcGFya2xpbmVzTm9ybWFsQmFuZDIuZGVmYXVsdDtcbmV4cG9ydHMuU3BhcmtsaW5lc1RleHQgPSBfU3BhcmtsaW5lc1RleHQyLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24ocHJvY2Vzcykgey8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cblxuXG52YXIgZW1wdHlGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgaW52YXJpYW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciB3YXJuaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBmb3IgdGhlIGAlc2AgcHJvcCBvbiBgJXNgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJyxcbiAgICAgICAgICAgICAgcHJvcEZ1bGxOYW1lLFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzKTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBwcm9wVmFsdWUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKHByb3BWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAlcyBhdCBpbmRleCAlcy4nLFxuICAgICAgICAgIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSxcbiAgICAgICAgICBpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSlcblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7LyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBpbnZhcmlhbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuICB2YXIgd2FybmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaW52YXJpYW50KHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICdSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lKTtcbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMikpKVxuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuXG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbnZhciBpbnZhcmlhbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gc2hpbShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGlmIChzZWNyZXQgPT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAvLyBJdCBpcyBzdGlsbCBzYWZlIHdoZW4gY2FsbGVkIGZyb20gUmVhY3QuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGludmFyaWFudChcbiAgICAgIGZhbHNlLFxuICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgJ1VzZSBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKSB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgKTtcbiAgfTtcbiAgc2hpbS5pc1JlcXVpcmVkID0gc2hpbTtcbiAgZnVuY3Rpb24gZ2V0U2hpbSgpIHtcbiAgICByZXR1cm4gc2hpbTtcbiAgfTtcbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBzaGltLFxuICAgIGJvb2w6IHNoaW0sXG4gICAgZnVuYzogc2hpbSxcbiAgICBudW1iZXI6IHNoaW0sXG4gICAgb2JqZWN0OiBzaGltLFxuICAgIHN0cmluZzogc2hpbSxcbiAgICBzeW1ib2w6IHNoaW0sXG5cbiAgICBhbnk6IHNoaW0sXG4gICAgYXJyYXlPZjogZ2V0U2hpbSxcbiAgICBlbGVtZW50OiBzaGltLFxuICAgIGluc3RhbmNlT2Y6IGdldFNoaW0sXG4gICAgbm9kZTogc2hpbSxcbiAgICBvYmplY3RPZjogZ2V0U2hpbSxcbiAgICBvbmVPZjogZ2V0U2hpbSxcbiAgICBvbmVPZlR5cGU6IGdldFNoaW0sXG4gICAgc2hhcGU6IGdldFNoaW1cbiAgfTtcblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGVtcHR5RnVuY3Rpb247XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfcHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxudmFyIF9yZWFjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBTcGFya2xpbmVzVGV4dCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKFNwYXJrbGluZXNUZXh0LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIFNwYXJrbGluZXNUZXh0KCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3BhcmtsaW5lc1RleHQpO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3BhcmtsaW5lc1RleHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTcGFya2xpbmVzVGV4dCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhTcGFya2xpbmVzVGV4dCwgW3tcbiAgICAgICAga2V5OiAncmVuZGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIHBvaW50ID0gX3Byb3BzLnBvaW50LFxuICAgICAgICAgICAgICAgIHRleHQgPSBfcHJvcHMudGV4dCxcbiAgICAgICAgICAgICAgICBmb250U2l6ZSA9IF9wcm9wcy5mb250U2l6ZSxcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5ID0gX3Byb3BzLmZvbnRGYW1pbHk7XG4gICAgICAgICAgICB2YXIgeCA9IHBvaW50LngsXG4gICAgICAgICAgICAgICAgeSA9IHBvaW50Lnk7XG5cbiAgICAgICAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnZycsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICB7IHg6IHgsIHk6IHksIGZvbnRGYW1pbHk6IGZvbnRGYW1pbHkgfHwgXCJWZXJkYW5hXCIsIGZvbnRTaXplOiBmb250U2l6ZSB8fCAxMCB9LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBTcGFya2xpbmVzVGV4dDtcbn0oX3JlYWN0Mi5kZWZhdWx0LkNvbXBvbmVudCk7XG5cblNwYXJrbGluZXNUZXh0LnByb3BUeXBlcyA9IHtcbiAgICB0ZXh0OiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcbiAgICBwb2ludDogX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QsXG4gICAgZm9udFNpemU6IF9wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyLFxuICAgIGZvbnRGYW1pbHk6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nXG59O1xuU3BhcmtsaW5lc1RleHQuZGVmYXVsdFByb3BzID0ge1xuICAgIHRleHQ6ICcnLFxuICAgIHBvaW50OiB7IHg6IDAsIHk6IDAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IFNwYXJrbGluZXNUZXh0O1xuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfcHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxudmFyIF9yZWFjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBTcGFya2xpbmVzTGluZSA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhTcGFya2xpbmVzTGluZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gU3BhcmtsaW5lc0xpbmUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwYXJrbGluZXNMaW5lKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3BhcmtsaW5lc0xpbmUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTcGFya2xpbmVzTGluZSkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNwYXJrbGluZXNMaW5lLCBbe1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcHJvcHMuZGF0YSxcbiAgICAgICAgICBwb2ludHMgPSBfcHJvcHMucG9pbnRzLFxuICAgICAgICAgIHdpZHRoID0gX3Byb3BzLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF9wcm9wcy5oZWlnaHQsXG4gICAgICAgICAgbWFyZ2luID0gX3Byb3BzLm1hcmdpbixcbiAgICAgICAgICBjb2xvciA9IF9wcm9wcy5jb2xvcixcbiAgICAgICAgICBzdHlsZSA9IF9wcm9wcy5zdHlsZSxcbiAgICAgICAgICBvbk1vdXNlTW92ZSA9IF9wcm9wcy5vbk1vdXNlTW92ZTtcblxuXG4gICAgICB2YXIgbGluZVBvaW50cyA9IHBvaW50cy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIFtwLngsIHAueV07XG4gICAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBjbG9zZVBvbHlQb2ludHMgPSBbcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXS54LCBoZWlnaHQgLSBtYXJnaW4sIG1hcmdpbiwgaGVpZ2h0IC0gbWFyZ2luLCBtYXJnaW4sIHBvaW50c1swXS55XTtcblxuICAgICAgdmFyIGZpbGxQb2ludHMgPSBsaW5lUG9pbnRzLmNvbmNhdChjbG9zZVBvbHlQb2ludHMpO1xuXG4gICAgICB2YXIgbGluZVN0eWxlID0ge1xuICAgICAgICBzdHJva2U6IGNvbG9yIHx8IHN0eWxlLnN0cm9rZSB8fCAnc2xhdGVncmF5JyxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHN0eWxlLnN0cm9rZVdpZHRoIHx8ICcxJyxcbiAgICAgICAgc3Ryb2tlTGluZWpvaW46IHN0eWxlLnN0cm9rZUxpbmVqb2luIHx8ICdyb3VuZCcsXG4gICAgICAgIHN0cm9rZUxpbmVjYXA6IHN0eWxlLnN0cm9rZUxpbmVjYXAgfHwgJ3JvdW5kJyxcbiAgICAgICAgZmlsbDogJ25vbmUnXG4gICAgICB9O1xuICAgICAgdmFyIGZpbGxTdHlsZSA9IHtcbiAgICAgICAgc3Ryb2tlOiBzdHlsZS5zdHJva2UgfHwgJ25vbmUnLFxuICAgICAgICBzdHJva2VXaWR0aDogJzAnLFxuICAgICAgICBmaWxsT3BhY2l0eTogc3R5bGUuZmlsbE9wYWNpdHkgfHwgJy4xJyxcbiAgICAgICAgZmlsbDogc3R5bGUuZmlsbCB8fCBjb2xvciB8fCAnc2xhdGVncmF5JyxcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ2F1dG8nXG4gICAgICB9O1xuXG4gICAgICB2YXIgdG9vbHRpcHMgPSBwb2ludHMubWFwKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgnY2lyY2xlJywge1xuICAgICAgICAgIGtleTogaSxcbiAgICAgICAgICBjeDogcC54LFxuICAgICAgICAgIGN5OiBwLnksXG4gICAgICAgICAgcjogMixcbiAgICAgICAgICBzdHlsZTogZmlsbFN0eWxlLFxuICAgICAgICAgIG9uTW91c2VFbnRlcjogZnVuY3Rpb24gb25Nb3VzZUVudGVyKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvbk1vdXNlTW92ZSgnZW50ZXInLCBkYXRhW2ldLCBwKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9uTW91c2VNb3ZlKCdjbGljaycsIGRhdGFbaV0sIHApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZycsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHRvb2x0aXBzLFxuICAgICAgICBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgncG9seWxpbmUnLCB7IHBvaW50czogZmlsbFBvaW50cy5qb2luKCcgJyksIHN0eWxlOiBmaWxsU3R5bGUgfSksXG4gICAgICAgIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCdwb2x5bGluZScsIHsgcG9pbnRzOiBsaW5lUG9pbnRzLmpvaW4oJyAnKSwgc3R5bGU6IGxpbmVTdHlsZSB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3BhcmtsaW5lc0xpbmU7XG59KF9yZWFjdDIuZGVmYXVsdC5Db21wb25lbnQpO1xuXG5TcGFya2xpbmVzTGluZS5wcm9wVHlwZXMgPSB7XG4gIGNvbG9yOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcbiAgc3R5bGU6IF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0XG59O1xuU3BhcmtsaW5lc0xpbmUuZGVmYXVsdFByb3BzID0ge1xuICBzdHlsZToge30sXG4gIG9uTW91c2VNb3ZlOiBmdW5jdGlvbiBvbk1vdXNlTW92ZSgpIHt9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gU3BhcmtsaW5lc0xpbmU7XG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3Byb3BUeXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcHJvcFR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb3BUeXBlcyk7XG5cbnZhciBfcmVhY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgU3BhcmtsaW5lc0N1cnZlID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoU3BhcmtsaW5lc0N1cnZlLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIFNwYXJrbGluZXNDdXJ2ZSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwYXJrbGluZXNDdXJ2ZSk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTcGFya2xpbmVzQ3VydmUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTcGFya2xpbmVzQ3VydmUpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU3BhcmtsaW5lc0N1cnZlLCBbe1xuICAgICAgICBrZXk6ICdyZW5kZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgcG9pbnRzID0gX3Byb3BzLnBvaW50cyxcbiAgICAgICAgICAgICAgICB3aWR0aCA9IF9wcm9wcy53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBfcHJvcHMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIG1hcmdpbiA9IF9wcm9wcy5tYXJnaW4sXG4gICAgICAgICAgICAgICAgY29sb3IgPSBfcHJvcHMuY29sb3IsXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBfcHJvcHMuc3R5bGUsXG4gICAgICAgICAgICAgICAgX3Byb3BzJGRpdmlzb3IgPSBfcHJvcHMuZGl2aXNvcixcbiAgICAgICAgICAgICAgICBkaXZpc29yID0gX3Byb3BzJGRpdmlzb3IgPT09IHVuZGVmaW5lZCA/IDAuMjUgOiBfcHJvcHMkZGl2aXNvcjtcblxuICAgICAgICAgICAgdmFyIHByZXYgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgY3VydmUgPSBmdW5jdGlvbiBjdXJ2ZShwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gW3AueCwgcC55XTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gKHAueCAtIHByZXYueCkgKiBkaXZpc29yO1xuICAgICAgICAgICAgICAgICAgICByZXMgPSBbXCJDXCIsXG4gICAgICAgICAgICAgICAgICAgIC8veDFcbiAgICAgICAgICAgICAgICAgICAgcHJldi54ICsgbGVuLFxuICAgICAgICAgICAgICAgICAgICAvL3kxXG4gICAgICAgICAgICAgICAgICAgIHByZXYueSxcbiAgICAgICAgICAgICAgICAgICAgLy94MixcbiAgICAgICAgICAgICAgICAgICAgcC54IC0gbGVuLFxuICAgICAgICAgICAgICAgICAgICAvL3kyLFxuICAgICAgICAgICAgICAgICAgICBwLnksXG4gICAgICAgICAgICAgICAgICAgIC8veCxcbiAgICAgICAgICAgICAgICAgICAgcC54LFxuICAgICAgICAgICAgICAgICAgICAvL3lcbiAgICAgICAgICAgICAgICAgICAgcC55XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldiA9IHA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbGluZVBvaW50cyA9IHBvaW50cy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VydmUocCk7XG4gICAgICAgICAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBjbG9zZVBvbHlQb2ludHMgPSBbXCJMXCIgKyBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLngsIGhlaWdodCAtIG1hcmdpbiwgbWFyZ2luLCBoZWlnaHQgLSBtYXJnaW4sIG1hcmdpbiwgcG9pbnRzWzBdLnldO1xuICAgICAgICAgICAgdmFyIGZpbGxQb2ludHMgPSBsaW5lUG9pbnRzLmNvbmNhdChjbG9zZVBvbHlQb2ludHMpO1xuXG4gICAgICAgICAgICB2YXIgbGluZVN0eWxlID0ge1xuICAgICAgICAgICAgICAgIHN0cm9rZTogY29sb3IgfHwgc3R5bGUuc3Ryb2tlIHx8ICdzbGF0ZWdyYXknLFxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHlsZS5zdHJva2VXaWR0aCB8fCAnMScsXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW46IHN0eWxlLnN0cm9rZUxpbmVqb2luIHx8ICdyb3VuZCcsXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcDogc3R5bGUuc3Ryb2tlTGluZWNhcCB8fCAncm91bmQnLFxuICAgICAgICAgICAgICAgIGZpbGw6ICdub25lJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBmaWxsU3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBzdHlsZS5zdHJva2UgfHwgJ25vbmUnLFxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAnMCcsXG4gICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IHN0eWxlLmZpbGxPcGFjaXR5IHx8ICcuMScsXG4gICAgICAgICAgICAgICAgZmlsbDogc3R5bGUuZmlsbCB8fCBjb2xvciB8fCAnc2xhdGVncmF5J1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdnJyxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgeyBkOiBcIk1cIiArIGZpbGxQb2ludHMuam9pbignICcpLCBzdHlsZTogZmlsbFN0eWxlIH0pLFxuICAgICAgICAgICAgICAgIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgeyBkOiBcIk1cIiArIGxpbmVQb2ludHMuam9pbignICcpLCBzdHlsZTogbGluZVN0eWxlIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFNwYXJrbGluZXNDdXJ2ZTtcbn0oX3JlYWN0Mi5kZWZhdWx0LkNvbXBvbmVudCk7XG5cblNwYXJrbGluZXNDdXJ2ZS5wcm9wVHlwZXMgPSB7XG4gICAgY29sb3I6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxuICAgIHN0eWxlOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdFxufTtcblNwYXJrbGluZXNDdXJ2ZS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgc3R5bGU6IHt9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gU3BhcmtsaW5lc0N1cnZlO1xuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfcHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxudmFyIF9yZWFjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBTcGFya2xpbmVzQmFycyA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhTcGFya2xpbmVzQmFycywgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gU3BhcmtsaW5lc0JhcnMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwYXJrbGluZXNCYXJzKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3BhcmtsaW5lc0JhcnMuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTcGFya2xpbmVzQmFycykpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNwYXJrbGluZXNCYXJzLCBbe1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBwb2ludHMgPSBfcHJvcHMucG9pbnRzLFxuICAgICAgICAgIGhlaWdodCA9IF9wcm9wcy5oZWlnaHQsXG4gICAgICAgICAgc3R5bGUgPSBfcHJvcHMuc3R5bGUsXG4gICAgICAgICAgYmFyV2lkdGggPSBfcHJvcHMuYmFyV2lkdGgsXG4gICAgICAgICAgbWFyZ2luID0gX3Byb3BzLm1hcmdpbixcbiAgICAgICAgICBvbk1vdXNlTW92ZSA9IF9wcm9wcy5vbk1vdXNlTW92ZTtcblxuICAgICAgdmFyIHN0cm9rZVdpZHRoID0gMSAqIChzdHlsZSAmJiBzdHlsZS5zdHJva2VXaWR0aCB8fCAwKTtcbiAgICAgIHZhciBtYXJnaW5XaWR0aCA9IG1hcmdpbiA/IDIgKiBtYXJnaW4gOiAwO1xuICAgICAgdmFyIHdpZHRoID0gYmFyV2lkdGggfHwgKHBvaW50cyAmJiBwb2ludHMubGVuZ3RoID49IDIgPyBNYXRoLm1heCgwLCBwb2ludHNbMV0ueCAtIHBvaW50c1swXS54IC0gc3Ryb2tlV2lkdGggLSBtYXJnaW5XaWR0aCkgOiAwKTtcblxuICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZycsXG4gICAgICAgIHsgdHJhbnNmb3JtOiAnc2NhbGUoMSwtMSknIH0sXG4gICAgICAgIHBvaW50cy5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoJ3JlY3QnLCB7XG4gICAgICAgICAgICBrZXk6IGksXG4gICAgICAgICAgICB4OiBwLnggLSAod2lkdGggKyBzdHJva2VXaWR0aCkgLyAyLFxuICAgICAgICAgICAgeTogLWhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogTWF0aC5tYXgoMCwgaGVpZ2h0IC0gcC55KSxcbiAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgIG9uTW91c2VNb3ZlOiBvbk1vdXNlTW92ZSAmJiBvbk1vdXNlTW92ZS5iaW5kKF90aGlzMiwgcClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNwYXJrbGluZXNCYXJzO1xufShfcmVhY3QyLmRlZmF1bHQuQ29tcG9uZW50KTtcblxuU3BhcmtsaW5lc0JhcnMucHJvcFR5cGVzID0ge1xuICBwb2ludHM6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYXJyYXlPZihfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdCksXG4gIGhlaWdodDogX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIsXG4gIHN0eWxlOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdCxcbiAgYmFyV2lkdGg6IF9wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyLFxuICBtYXJnaW46IF9wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyLFxuICBvbk1vdXNlTW92ZTogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jXG59O1xuU3BhcmtsaW5lc0JhcnMuZGVmYXVsdFByb3BzID0ge1xuICBzdHlsZTogeyBmaWxsOiAnc2xhdGVncmF5JyB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gU3BhcmtsaW5lc0JhcnM7XG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3Byb3BUeXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcHJvcFR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb3BUeXBlcyk7XG5cbnZhciBfcmVhY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgU3BhcmtsaW5lc1Nwb3RzID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoU3BhcmtsaW5lc1Nwb3RzLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIFNwYXJrbGluZXNTcG90cygpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwYXJrbGluZXNTcG90cyk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTcGFya2xpbmVzU3BvdHMuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTcGFya2xpbmVzU3BvdHMpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU3BhcmtsaW5lc1Nwb3RzLCBbe1xuICAgICAgICBrZXk6ICdsYXN0RGlyZWN0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxhc3REaXJlY3Rpb24ocG9pbnRzKSB7XG5cbiAgICAgICAgICAgIE1hdGguc2lnbiA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4ID4gMCA/IDEgOiAtMTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubGVuZ3RoIDwgMiA/IDAgOiBNYXRoLnNpZ24ocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXS55IC0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXS55KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVuZGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIHBvaW50cyA9IF9wcm9wcy5wb2ludHMsXG4gICAgICAgICAgICAgICAgd2lkdGggPSBfcHJvcHMud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gX3Byb3BzLmhlaWdodCxcbiAgICAgICAgICAgICAgICBzaXplID0gX3Byb3BzLnNpemUsXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBfcHJvcHMuc3R5bGUsXG4gICAgICAgICAgICAgICAgc3BvdENvbG9ycyA9IF9wcm9wcy5zcG90Q29sb3JzO1xuXG5cbiAgICAgICAgICAgIHZhciBzdGFydFNwb3QgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgnY2lyY2xlJywge1xuICAgICAgICAgICAgICAgIGN4OiBwb2ludHNbMF0ueCxcbiAgICAgICAgICAgICAgICBjeTogcG9pbnRzWzBdLnksXG4gICAgICAgICAgICAgICAgcjogc2l6ZSxcbiAgICAgICAgICAgICAgICBzdHlsZTogc3R5bGUgfSk7XG5cbiAgICAgICAgICAgIHZhciBlbmRTcG90ID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoJ2NpcmNsZScsIHtcbiAgICAgICAgICAgICAgICBjeDogcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXS54LFxuICAgICAgICAgICAgICAgIGN5OiBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLnksXG4gICAgICAgICAgICAgICAgcjogc2l6ZSxcbiAgICAgICAgICAgICAgICBzdHlsZTogc3R5bGUgfHwgeyBmaWxsOiBzcG90Q29sb3JzW3RoaXMubGFzdERpcmVjdGlvbihwb2ludHMpXSB9IH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ2cnLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgc3R5bGUgJiYgc3RhcnRTcG90LFxuICAgICAgICAgICAgICAgIGVuZFNwb3RcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gU3BhcmtsaW5lc1Nwb3RzO1xufShfcmVhY3QyLmRlZmF1bHQuQ29tcG9uZW50KTtcblxuU3BhcmtsaW5lc1Nwb3RzLnByb3BUeXBlcyA9IHtcbiAgICBzaXplOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm51bWJlcixcbiAgICBzdHlsZTogX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QsXG4gICAgc3BvdENvbG9yczogX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3Rcbn07XG5TcGFya2xpbmVzU3BvdHMuZGVmYXVsdFByb3BzID0ge1xuICAgIHNpemU6IDIsXG4gICAgc3BvdENvbG9yczoge1xuICAgICAgICAnLTEnOiAncmVkJyxcbiAgICAgICAgJzAnOiAnYmxhY2snLFxuICAgICAgICAnMSc6ICdncmVlbidcbiAgICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gU3BhcmtsaW5lc1Nwb3RzO1xuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9wcm9wVHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG52YXIgX3JlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfZGF0YVByb2Nlc3NpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxudmFyIGRhdGFQcm9jZXNzaW5nID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2RhdGFQcm9jZXNzaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgU3BhcmtsaW5lc1JlZmVyZW5jZUxpbmUgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhTcGFya2xpbmVzUmVmZXJlbmNlTGluZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBTcGFya2xpbmVzUmVmZXJlbmNlTGluZSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwYXJrbGluZXNSZWZlcmVuY2VMaW5lKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFNwYXJrbGluZXNSZWZlcmVuY2VMaW5lLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3BhcmtsaW5lc1JlZmVyZW5jZUxpbmUpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU3BhcmtsaW5lc1JlZmVyZW5jZUxpbmUsIFt7XG4gICAgICAgIGtleTogJ3JlbmRlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBfcHJvcHMucG9pbnRzLFxuICAgICAgICAgICAgICAgIG1hcmdpbiA9IF9wcm9wcy5tYXJnaW4sXG4gICAgICAgICAgICAgICAgdHlwZSA9IF9wcm9wcy50eXBlLFxuICAgICAgICAgICAgICAgIHN0eWxlID0gX3Byb3BzLnN0eWxlLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gX3Byb3BzLnZhbHVlO1xuXG5cbiAgICAgICAgICAgIHZhciB5cG9pbnRzID0gcG9pbnRzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwLnk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciB5ID0gdHlwZSA9PSAnY3VzdG9tJyA/IHZhbHVlIDogZGF0YVByb2Nlc3NpbmdbdHlwZV0oeXBvaW50cyk7XG5cbiAgICAgICAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgnbGluZScsIHtcbiAgICAgICAgICAgICAgICB4MTogcG9pbnRzWzBdLngsIHkxOiB5ICsgbWFyZ2luLFxuICAgICAgICAgICAgICAgIHgyOiBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLngsIHkyOiB5ICsgbWFyZ2luLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZSB9KTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBTcGFya2xpbmVzUmVmZXJlbmNlTGluZTtcbn0oX3JlYWN0Mi5kZWZhdWx0LkNvbXBvbmVudCk7XG5cblNwYXJrbGluZXNSZWZlcmVuY2VMaW5lLnByb3BUeXBlcyA9IHtcbiAgICB0eXBlOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mKFsnbWF4JywgJ21pbicsICdtZWFuJywgJ2F2ZycsICdtZWRpYW4nLCAnY3VzdG9tJ10pLFxuICAgIHZhbHVlOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm51bWJlcixcbiAgICBzdHlsZTogX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3Rcbn07XG5TcGFya2xpbmVzUmVmZXJlbmNlTGluZS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgdHlwZTogJ21lYW4nLFxuICAgIHN0eWxlOiB7IHN0cm9rZTogJ3JlZCcsIHN0cm9rZU9wYWNpdHk6IC43NSwgc3Ryb2tlRGFzaGFycmF5OiAnMiwgMicgfVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IFNwYXJrbGluZXNSZWZlcmVuY2VMaW5lO1xuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnZhcmlhbmNlID0gZXhwb3J0cy5zdGRldiA9IGV4cG9ydHMubWVkaWFuID0gZXhwb3J0cy5taWRSYW5nZSA9IGV4cG9ydHMuYXZnID0gZXhwb3J0cy5tZWFuID0gZXhwb3J0cy5tYXggPSBleHBvcnRzLm1pbiA9IHVuZGVmaW5lZDtcblxudmFyIF9taW4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF9taW4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWluMik7XG5cbnZhciBfbWVhbjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX21lYW4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWVhbjIpO1xuXG52YXIgX21pZFJhbmdlMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xuXG52YXIgX21pZFJhbmdlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21pZFJhbmdlMik7XG5cbnZhciBfbWVkaWFuMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuXG52YXIgX21lZGlhbjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZWRpYW4yKTtcblxudmFyIF9zdGRldjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIF9zdGRldjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdGRldjIpO1xuXG52YXIgX3ZhcmlhbmNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuXG52YXIgX3ZhcmlhbmNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZhcmlhbmNlMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMubWluID0gX21pbjMuZGVmYXVsdDtcbmV4cG9ydHMubWF4ID0gX21pbjMuZGVmYXVsdDtcbmV4cG9ydHMubWVhbiA9IF9tZWFuMy5kZWZhdWx0O1xuZXhwb3J0cy5hdmcgPSBfbWVhbjMuZGVmYXVsdDtcbmV4cG9ydHMubWlkUmFuZ2UgPSBfbWlkUmFuZ2UzLmRlZmF1bHQ7XG5leHBvcnRzLm1lZGlhbiA9IF9tZWRpYW4zLmRlZmF1bHQ7XG5leHBvcnRzLnN0ZGV2ID0gX3N0ZGV2My5kZWZhdWx0O1xuZXhwb3J0cy52YXJpYW5jZSA9IF92YXJpYW5jZTMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG4vKiAyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbWluID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF9taW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWluKTtcblxudmFyIF9tYXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX21heDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXgpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiAoMCwgX21heDIuZGVmYXVsdCkoZGF0YSkgLSAoMCwgX21pbjIuZGVmYXVsdCkoZGF0YSkgLyAyO1xufTtcblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgfSlbTWF0aC5mbG9vcihkYXRhLmxlbmd0aCAvIDIpXTtcbn07XG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX21lYW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX21lYW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWVhbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGRhdGFNZWFuID0gKDAsIF9tZWFuMi5kZWZhdWx0KShkYXRhKTtcbiAgICB2YXIgc3EgPSBkYXRhLm1hcChmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gTWF0aC5wb3cobiAtIGRhdGFNZWFuLCAyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKDAsIF9tZWFuMi5kZWZhdWx0KShzcSk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9wcm9wVHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG52YXIgX3JlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfbWVhbiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfbWVhbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZWFuKTtcblxudmFyIF9zdGRldiA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG52YXIgX3N0ZGV2MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0ZGV2KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgU3BhcmtsaW5lc05vcm1hbEJhbmQgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhTcGFya2xpbmVzTm9ybWFsQmFuZCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBTcGFya2xpbmVzTm9ybWFsQmFuZCgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwYXJrbGluZXNOb3JtYWxCYW5kKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFNwYXJrbGluZXNOb3JtYWxCYW5kLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3BhcmtsaW5lc05vcm1hbEJhbmQpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU3BhcmtsaW5lc05vcm1hbEJhbmQsIFt7XG4gICAgICAgIGtleTogJ3JlbmRlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBfcHJvcHMucG9pbnRzLFxuICAgICAgICAgICAgICAgIG1hcmdpbiA9IF9wcm9wcy5tYXJnaW4sXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBfcHJvcHMuc3R5bGU7XG5cblxuICAgICAgICAgICAgdmFyIHlwb2ludHMgPSBwb2ludHMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHAueTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGRhdGFNZWFuID0gKDAsIF9tZWFuMi5kZWZhdWx0KSh5cG9pbnRzKTtcbiAgICAgICAgICAgIHZhciBkYXRhU3RkZXYgPSAoMCwgX3N0ZGV2Mi5kZWZhdWx0KSh5cG9pbnRzKTtcblxuICAgICAgICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCdyZWN0JywgeyB4OiBwb2ludHNbMF0ueCwgeTogZGF0YU1lYW4gLSBkYXRhU3RkZXYgKyBtYXJnaW4sXG4gICAgICAgICAgICAgICAgd2lkdGg6IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0ueCAtIHBvaW50c1swXS54LCBoZWlnaHQ6IF9zdGRldjIuZGVmYXVsdCAqIDIsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlIH0pO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFNwYXJrbGluZXNOb3JtYWxCYW5kO1xufShfcmVhY3QyLmRlZmF1bHQuQ29tcG9uZW50KTtcblxuU3BhcmtsaW5lc05vcm1hbEJhbmQucHJvcFR5cGVzID0ge1xuICAgIHN0eWxlOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdFxufTtcblNwYXJrbGluZXNOb3JtYWxCYW5kLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBzdHlsZTogeyBmaWxsOiAncmVkJywgZmlsbE9wYWNpdHk6IC4xIH1cbn07XG5leHBvcnRzLmRlZmF1bHQgPSBTcGFya2xpbmVzTm9ybWFsQmFuZDtcblxuLyoqKi8gfSksXG4vKiAyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbWluID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF9taW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWluKTtcblxudmFyIF9tYXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX21heDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXgpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgICBsaW1pdCA9IF9yZWYubGltaXQsXG4gICAgICAgIF9yZWYkd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgICB3aWR0aCA9IF9yZWYkd2lkdGggPT09IHVuZGVmaW5lZCA/IDEgOiBfcmVmJHdpZHRoLFxuICAgICAgICBfcmVmJGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgICAgICBoZWlnaHQgPSBfcmVmJGhlaWdodCA9PT0gdW5kZWZpbmVkID8gMSA6IF9yZWYkaGVpZ2h0LFxuICAgICAgICBfcmVmJG1hcmdpbiA9IF9yZWYubWFyZ2luLFxuICAgICAgICBtYXJnaW4gPSBfcmVmJG1hcmdpbiA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkbWFyZ2luLFxuICAgICAgICBfcmVmJG1heCA9IF9yZWYubWF4LFxuICAgICAgICBtYXggPSBfcmVmJG1heCA9PT0gdW5kZWZpbmVkID8gKDAsIF9tYXgyLmRlZmF1bHQpKGRhdGEpIDogX3JlZiRtYXgsXG4gICAgICAgIF9yZWYkbWluID0gX3JlZi5taW4sXG4gICAgICAgIG1pbiA9IF9yZWYkbWluID09PSB1bmRlZmluZWQgPyAoMCwgX21pbjIuZGVmYXVsdCkoZGF0YSkgOiBfcmVmJG1pbjtcblxuXG4gICAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xuXG4gICAgaWYgKGxpbWl0ICYmIGxpbWl0IDwgbGVuKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKGxlbiAtIGxpbWl0KTtcbiAgICB9XG5cbiAgICB2YXIgdmZhY3RvciA9IChoZWlnaHQgLSBtYXJnaW4gKiAyKSAvIChtYXggLSBtaW4gfHwgMik7XG4gICAgdmFyIGhmYWN0b3IgPSAod2lkdGggLSBtYXJnaW4gKiAyKSAvICgobGltaXQgfHwgbGVuKSAtIChsZW4gPiAxID8gMSA6IDApKTtcblxuICAgIHJldHVybiBkYXRhLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogaSAqIGhmYWN0b3IgKyBtYXJnaW4sXG4gICAgICAgICAgICB5OiAobWF4ID09PSBtaW4gPyAxIDogbWF4IC0gZCkgKiB2ZmFjdG9yICsgbWFyZ2luXG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTsiXSwibmFtZXMiOlsid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiZGVmaW5lIiwiYW1kIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xX18iLCJtb2R1bGVzIiwiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImkiLCJsIiwiY2FsbCIsIm0iLCJjIiwiZCIsIm5hbWUiLCJnZXR0ZXIiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwibiIsIl9fZXNNb2R1bGUiLCJnZXREZWZhdWx0IiwiZ2V0TW9kdWxlRXhwb3J0cyIsIm9iamVjdCIsInByb3BlcnR5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsInByb2Nlc3MiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJpc1ZhbGlkRWxlbWVudCIsIiQkdHlwZW9mIiwidGhyb3dPbkRpcmVjdEFjY2VzcyIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiRXJyb3IiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImUiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJsZW5ndGgiLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwidGltZW91dCIsImxlbiIsInJ1biIsIm5leHRUaWNrIiwiYXJncyIsIkFycmF5IiwiYXJndW1lbnRzIiwicHVzaCIsIkl0ZW0iLCJhcnJheSIsImFwcGx5IiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJiaW5kaW5nIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayIsInZhbHVlIiwiZGVmYXVsdCIsImRhdGEiLCJyZWR1Y2UiLCJhIiwiYiIsIm1ha2VFbXB0eUZ1bmN0aW9uIiwiYXJnIiwiZW1wdHlGdW5jdGlvbiIsInRoYXRSZXR1cm5zIiwidGhhdFJldHVybnNGYWxzZSIsInRoYXRSZXR1cm5zVHJ1ZSIsInRoYXRSZXR1cm5zTnVsbCIsInRoYXRSZXR1cm5zVGhpcyIsInRoYXRSZXR1cm5zQXJndW1lbnQiLCJ2YWxpZGF0ZUZvcm1hdCIsImZvcm1hdCIsInVuZGVmaW5lZCIsImludmFyaWFudCIsImNvbmRpdGlvbiIsImYiLCJlcnJvciIsImFyZ0luZGV4IiwicmVwbGFjZSIsImZyYW1lc1RvUG9wIiwiUmVhY3RQcm9wVHlwZXNTZWNyZXQiLCJNYXRoIiwibWluIiwid2FybmluZyIsInByaW50V2FybmluZyIsIl9sZW4iLCJfa2V5IiwibWVzc2FnZSIsImNvbnNvbGUiLCJ4IiwiaW5kZXhPZiIsIl9sZW4yIiwiX2tleTIiLCJtYXgiLCJfbWVhbiIsIl9tZWFuMiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJvYmoiLCJkYXRhTWVhbiIsInNxRGlmZiIsIm1hcCIsInBvdyIsImF2Z1NxRGlmZiIsInNxcnQiLCJTcGFya2xpbmVzVGV4dCIsIlNwYXJrbGluZXNOb3JtYWxCYW5kIiwiU3BhcmtsaW5lc1JlZmVyZW5jZUxpbmUiLCJTcGFya2xpbmVzU3BvdHMiLCJTcGFya2xpbmVzQmFycyIsIlNwYXJrbGluZXNDdXJ2ZSIsIlNwYXJrbGluZXNMaW5lIiwiU3BhcmtsaW5lcyIsIl9jcmVhdGVDbGFzcyIsImRlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJ3cml0YWJsZSIsImtleSIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX3Byb3BUeXBlcyIsIl9wcm9wVHlwZXMyIiwiX3JlYWN0IiwiX3JlYWN0MiIsIl9TcGFya2xpbmVzVGV4dCIsIl9TcGFya2xpbmVzVGV4dDIiLCJfU3BhcmtsaW5lc0xpbmUiLCJfU3BhcmtsaW5lc0xpbmUyIiwiX1NwYXJrbGluZXNDdXJ2ZSIsIl9TcGFya2xpbmVzQ3VydmUyIiwiX1NwYXJrbGluZXNCYXJzIiwiX1NwYXJrbGluZXNCYXJzMiIsIl9TcGFya2xpbmVzU3BvdHMiLCJfU3BhcmtsaW5lc1Nwb3RzMiIsIl9TcGFya2xpbmVzUmVmZXJlbmNlTGluZSIsIl9TcGFya2xpbmVzUmVmZXJlbmNlTGluZTIiLCJfU3BhcmtsaW5lc05vcm1hbEJhbmQiLCJfU3BhcmtsaW5lc05vcm1hbEJhbmQyIiwiX2RhdGFUb1BvaW50cyIsIl9kYXRhVG9Qb2ludHMyIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJUeXBlRXJyb3IiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJfUHVyZUNvbXBvbmVudCIsImdldFByb3RvdHlwZU9mIiwicmVuZGVyIiwiX3Byb3BzIiwibGltaXQiLCJ3aWR0aCIsImhlaWdodCIsInN2Z1dpZHRoIiwic3ZnSGVpZ2h0IiwicHJlc2VydmVBc3BlY3RSYXRpbyIsIm1hcmdpbiIsInN0eWxlIiwicG9pbnRzIiwic3ZnT3B0cyIsInZpZXdCb3giLCJjcmVhdGVFbGVtZW50IiwiQ2hpbGRyZW4iLCJjaGlsZHJlbiIsImNoaWxkIiwiY2xvbmVFbGVtZW50IiwiUHVyZUNvbXBvbmVudCIsInByb3BUeXBlcyIsIm51bWJlciIsInN0cmluZyIsIm9uTW91c2VNb3ZlIiwiZnVuYyIsImRlZmF1bHRQcm9wcyIsImNoZWNrUHJvcFR5cGVzIiwiSVRFUkFUT1JfU1lNQk9MIiwiaXRlcmF0b3IiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsImdldEl0ZXJhdG9yRm4iLCJtYXliZUl0ZXJhYmxlIiwiaXRlcmF0b3JGbiIsIkFOT05ZTU9VUyIsIlJlYWN0UHJvcFR5cGVzIiwiY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIiLCJib29sIiwic3ltYm9sIiwiYW55IiwiY3JlYXRlQW55VHlwZUNoZWNrZXIiLCJhcnJheU9mIiwiY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyIiwiZWxlbWVudCIsImNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlciIsImluc3RhbmNlT2YiLCJjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyIiwibm9kZSIsImNyZWF0ZU5vZGVDaGVja2VyIiwib2JqZWN0T2YiLCJjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyIiwib25lT2YiLCJjcmVhdGVFbnVtVHlwZUNoZWNrZXIiLCJvbmVPZlR5cGUiLCJjcmVhdGVVbmlvblR5cGVDaGVja2VyIiwic2hhcGUiLCJjcmVhdGVTaGFwZVR5cGVDaGVja2VyIiwiaXMiLCJ5IiwiUHJvcFR5cGVFcnJvciIsInN0YWNrIiwiY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIiLCJ2YWxpZGF0ZSIsIm1hbnVhbFByb3BUeXBlQ2FsbENhY2hlIiwibWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQiLCJjaGVja1R5cGUiLCJpc1JlcXVpcmVkIiwicHJvcE5hbWUiLCJjb21wb25lbnROYW1lIiwibG9jYXRpb24iLCJwcm9wRnVsbE5hbWUiLCJzZWNyZXQiLCJjYWNoZUtleSIsImNoYWluZWRDaGVja1R5cGUiLCJiaW5kIiwiZXhwZWN0ZWRUeXBlIiwicHJvcFZhbHVlIiwicHJvcFR5cGUiLCJnZXRQcm9wVHlwZSIsInByZWNpc2VUeXBlIiwiZ2V0UHJlY2lzZVR5cGUiLCJ0eXBlQ2hlY2tlciIsImlzQXJyYXkiLCJleHBlY3RlZENsYXNzIiwiZXhwZWN0ZWRDbGFzc05hbWUiLCJhY3R1YWxDbGFzc05hbWUiLCJnZXRDbGFzc05hbWUiLCJleHBlY3RlZFZhbHVlcyIsInZhbHVlc1N0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJhcnJheU9mVHlwZUNoZWNrZXJzIiwiY2hlY2tlciIsImdldFBvc3RmaXhGb3JUeXBlV2FybmluZyIsImlzTm9kZSIsInNoYXBlVHlwZXMiLCJldmVyeSIsInN0ZXAiLCJlbnRyaWVzIiwibmV4dCIsImRvbmUiLCJlbnRyeSIsImlzU3ltYm9sIiwiUmVnRXhwIiwiRGF0ZSIsInR5cGUiLCJQcm9wVHlwZXMiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJnZXRTdGFjayIsInR5cGVTcGVjTmFtZSIsImV4Iiwic2hpbSIsImdldFNoaW0iLCJfUmVhY3QkQ29tcG9uZW50IiwicG9pbnQiLCJ0ZXh0IiwiZm9udFNpemUiLCJmb250RmFtaWx5IiwiQ29tcG9uZW50IiwiY29sb3IiLCJsaW5lUG9pbnRzIiwiY2xvc2VQb2x5UG9pbnRzIiwiZmlsbFBvaW50cyIsImxpbmVTdHlsZSIsInN0cm9rZSIsInN0cm9rZVdpZHRoIiwic3Ryb2tlTGluZWpvaW4iLCJzdHJva2VMaW5lY2FwIiwiZmlsbCIsImZpbGxTdHlsZSIsImZpbGxPcGFjaXR5IiwicG9pbnRlckV2ZW50cyIsInRvb2x0aXBzIiwiY3giLCJjeSIsInIiLCJvbk1vdXNlRW50ZXIiLCJvbkNsaWNrIiwiam9pbiIsIl9wcm9wcyRkaXZpc29yIiwiZGl2aXNvciIsInByZXYiLCJjdXJ2ZSIsInJlcyIsIl90aGlzMiIsImJhcldpZHRoIiwibWFyZ2luV2lkdGgiLCJ0cmFuc2Zvcm0iLCJsYXN0RGlyZWN0aW9uIiwic2lnbiIsInNpemUiLCJzcG90Q29sb3JzIiwic3RhcnRTcG90IiwiZW5kU3BvdCIsIl9kYXRhUHJvY2Vzc2luZyIsImRhdGFQcm9jZXNzaW5nIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJuZXdPYmoiLCJ5cG9pbnRzIiwieDEiLCJ5MSIsIngyIiwieTIiLCJzdHJva2VPcGFjaXR5Iiwic3Ryb2tlRGFzaGFycmF5IiwidmFyaWFuY2UiLCJzdGRldiIsIm1lZGlhbiIsIm1pZFJhbmdlIiwiYXZnIiwibWVhbiIsIl9taW4yIiwiX21pbjMiLCJfbWVhbjMiLCJfbWlkUmFuZ2UyIiwiX21pZFJhbmdlMyIsIl9tZWRpYW4yIiwiX21lZGlhbjMiLCJfc3RkZXYyIiwiX3N0ZGV2MyIsIl92YXJpYW5jZTIiLCJfdmFyaWFuY2UzIiwiX21pbiIsIl9tYXgiLCJfbWF4MiIsInNvcnQiLCJmbG9vciIsInNxIiwiX3N0ZGV2IiwiZGF0YVN0ZGV2IiwiX3JlZiIsIl9yZWYkd2lkdGgiLCJfcmVmJGhlaWdodCIsIl9yZWYkbWFyZ2luIiwiX3JlZiRtYXgiLCJfcmVmJG1pbiIsInNsaWNlIiwidmZhY3RvciIsImhmYWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-sparklines/build/index.js\n");

/***/ })

};
;